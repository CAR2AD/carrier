
<h1> module carrier::pq </h1>
<h4> fn clear (

    usize
    qt,

    ::carrier::pq::Q*+qt
    self,

)



</h4>

<p class='doc_comments'>

</p><h4> fn send (

    ::carrier::pq::Q*+qt
    self,

    usize
    qt,

    u16
    buflen,

    u64
    counter,

    u64
    time,

    u8*
    buf,

)

-&gt usize

</h4>

<p class='doc_comments'>
 send frames out of the queue&lt;br&gt;
</p><h4> fn window (

    ::carrier::pq::Q*+qt
    self,

    usize
    qt,

)

-&gt usize

</h4>

<p class='doc_comments'>

</p><h4> fn cancel (

    usize
    qt,

    ::carrier::pq::Q*+qt
    self,

)



</h4>

<p class='doc_comments'>
 undo last allocation without sending anything&lt;br&gt;
</p><h4> fn keepalive (

    u64
    now,

    ::carrier::pq::Q*+qt
    self,

    usize
    qt,

)

-&gt u64

</h4>

<p class='doc_comments'>
 tail loss probe or ping and return the time when we need to call this function again&lt;br&gt;
</p><h4> fn swap16 (

    u16
    x,

)

-&gt u16

</h4>

<p class='doc_comments'>

</p><h4> fn to_be16 (

    u16
    x,

)

-&gt u16

</h4>

<p class='doc_comments'>

</p><h4> fn alloc (

    usize
    qt,

    usize
    et,

    ::err::Err*+et
    e,

    ::carrier::pq::Q*+qt
    self,

    usize
    size,

    ::carrier::channel::FrameType
    typ,

)

-&gt ::slice::mut_slice::MutSlice

</h4>

<p class='doc_comments'>
 allocate the next frame in the queue&lt;br&gt;
</p><h4> fn ack (

    ::carrier::pq::Q*+qt
    self,

    usize
    qt,

    u64
    time,

    u64
    counter,

)



</h4>

<p class='doc_comments'>

</p>













