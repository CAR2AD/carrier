using slice;
using madpack;

export enum Path__Category {
  Invalid = 0,
  Local = 1,
  Internet = 2,
  BrokerOrigin = 3,
}

export enum Path {
  Ipaddr = 1,
  Category = 2,
}

export fn PathUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Path::Ipaddr => {
            return slice::slice::Slice{mem: (u8*)"ipaddr", size: 6};
        }
        Path::Category => {
            return slice::slice::Slice{mem: (u8*)"category", size: 8};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum FilterByRole {
  Roles = 1,
}

export fn FilterByRoleUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        FilterByRole::Roles => {
            return slice::slice::Slice{mem: (u8*)"roles", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Filter {
  Role = 1,
}

export fn FilterUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Filter::Role => {
            next->unpacker = FilterByRoleUnpacker;
            return slice::slice::Slice{mem: (u8*)"role", size: 4};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum SubscribeRequest {
  Shadow = 1,
  Filter = 2,
  GroupKey = 3,
  GroupShard = 4,
  ShardWeight = 5,
}

export fn SubscribeRequestUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        SubscribeRequest::Shadow => {
            return slice::slice::Slice{mem: (u8*)"shadow", size: 6};
        }
        SubscribeRequest::Filter => {
            next->unpacker = FilterUnpacker;
            return slice::slice::Slice{mem: (u8*)"filter", size: 6};
        }
        SubscribeRequest::GroupKey => {
            return slice::slice::Slice{mem: (u8*)"group_key", size: 9};
        }
        SubscribeRequest::GroupShard => {
            return slice::slice::Slice{mem: (u8*)"group_shard", size: 11};
        }
        SubscribeRequest::ShardWeight => {
            return slice::slice::Slice{mem: (u8*)"shard_weight", size: 12};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Publish {
  Identity = 1,
  Xaddr = 2,
}

export fn PublishUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Publish::Identity => {
            return slice::slice::Slice{mem: (u8*)"identity", size: 8};
        }
        Publish::Xaddr => {
            return slice::slice::Slice{mem: (u8*)"xaddr", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Unpublish {
  Identity = 1,
}

export fn UnpublishUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Unpublish::Identity => {
            return slice::slice::Slice{mem: (u8*)"identity", size: 8};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export fn SupersedeUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum SubscribeChange {
  Publish = 1,
  Unpublish = 2,
  Supersede = 3,
}

export fn SubscribeChangeUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        SubscribeChange::Publish => {
            next->unpacker = PublishUnpacker;
            return slice::slice::Slice{mem: (u8*)"publish", size: 7};
        }
        SubscribeChange::Unpublish => {
            next->unpacker = UnpublishUnpacker;
            return slice::slice::Slice{mem: (u8*)"unpublish", size: 9};
        }
        SubscribeChange::Supersede => {
            next->unpacker = SupersedeUnpacker;
            return slice::slice::Slice{mem: (u8*)"supersede", size: 9};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum PublishRequest {
  Unused = 1,
  Network = 2,
  ReceiveAlias = 3,
}

export fn PublishRequestUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        PublishRequest::Unused => {
            return slice::slice::Slice{mem: (u8*)"unused", size: 6};
        }
        PublishRequest::Network => {
            return slice::slice::Slice{mem: (u8*)"network", size: 7};
        }
        PublishRequest::ReceiveAlias => {
            return slice::slice::Slice{mem: (u8*)"receive_alias", size: 13};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Alias {
  Alias = 2,
}

export fn AliasUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Alias::Alias => {
            return slice::slice::Slice{mem: (u8*)"alias", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum PublishChange {
  Supersede = 1,
  Alias = 2,
}

export fn PublishChangeUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        PublishChange::Supersede => {
            next->unpacker = SupersedeUnpacker;
            return slice::slice::Slice{mem: (u8*)"supersede", size: 9};
        }
        PublishChange::Alias => {
            next->unpacker = AliasUnpacker;
            return slice::slice::Slice{mem: (u8*)"alias", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum ConnectRequest__TargetType {
  Identity = 0,
  Alias = 1,
}

export enum ConnectRequest {
  Target = 1,
  Timestamp = 2,
  Handshake = 3,
  Paths = 4,
  Principal = 5,
  Timeout = 6,
  TargetType = 7,
}

export fn ConnectRequestUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        ConnectRequest::Target => {
            return slice::slice::Slice{mem: (u8*)"target", size: 6};
        }
        ConnectRequest::Timestamp => {
            return slice::slice::Slice{mem: (u8*)"timestamp", size: 9};
        }
        ConnectRequest::Handshake => {
            return slice::slice::Slice{mem: (u8*)"handshake", size: 9};
        }
        ConnectRequest::Paths => {
            next->unpacker = PathUnpacker;
            return slice::slice::Slice{mem: (u8*)"paths", size: 5};
        }
        ConnectRequest::Principal => {
            return slice::slice::Slice{mem: (u8*)"principal", size: 9};
        }
        ConnectRequest::Timeout => {
            return slice::slice::Slice{mem: (u8*)"timeout", size: 7};
        }
        ConnectRequest::TargetType => {
            return slice::slice::Slice{mem: (u8*)"target_type", size: 11};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum ConnectResponse {
  Ok = 1,
  Handshake = 2,
  Route = 3,
  Paths = 4,
  Error = 5,
}

export fn ConnectResponseUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        ConnectResponse::Ok => {
            return slice::slice::Slice{mem: (u8*)"ok", size: 2};
        }
        ConnectResponse::Handshake => {
            return slice::slice::Slice{mem: (u8*)"handshake", size: 9};
        }
        ConnectResponse::Route => {
            return slice::slice::Slice{mem: (u8*)"route", size: 5};
        }
        ConnectResponse::Paths => {
            next->unpacker = PathUnpacker;
            return slice::slice::Slice{mem: (u8*)"paths", size: 5};
        }
        ConnectResponse::Error => {
            return slice::slice::Slice{mem: (u8*)"error", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum ClusterShard {
  This = 1,
  Other = 2,
}

export fn ClusterShardUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        ClusterShard::This => {
            return slice::slice::Slice{mem: (u8*)"this", size: 4};
        }
        ClusterShard::Other => {
            return slice::slice::Slice{mem: (u8*)"other", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum ExceptionalRoute {
  Identity = 1,
  This = 2,
  Other = 3,
  Blocked = 4,
}

export fn ExceptionalRouteUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        ExceptionalRoute::Identity => {
            return slice::slice::Slice{mem: (u8*)"identity", size: 8};
        }
        ExceptionalRoute::This => {
            return slice::slice::Slice{mem: (u8*)"this", size: 4};
        }
        ExceptionalRoute::Other => {
            return slice::slice::Slice{mem: (u8*)"other", size: 5};
        }
        ExceptionalRoute::Blocked => {
            return slice::slice::Slice{mem: (u8*)"blocked", size: 7};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum ClusterConfig {
  Shards = 1,
  ExceptionalRoutes = 2,
  Epoch = 3,
  DefaultShadowPublisherLimit = 4,
  DefaultShadowTrafficLimit32 = 5,
}

export fn ClusterConfigUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        ClusterConfig::Shards => {
            next->unpacker = ClusterShardUnpacker;
            return slice::slice::Slice{mem: (u8*)"shards", size: 6};
        }
        ClusterConfig::ExceptionalRoutes => {
            next->unpacker = ExceptionalRouteUnpacker;
            return slice::slice::Slice{mem: (u8*)"exceptional_routes", size: 18};
        }
        ClusterConfig::Epoch => {
            return slice::slice::Slice{mem: (u8*)"epoch", size: 5};
        }
        ClusterConfig::DefaultShadowPublisherLimit => {
            return slice::slice::Slice{mem: (u8*)"default_shadow_publisher_limit", size: 30};
        }
        ClusterConfig::DefaultShadowTrafficLimit32 => {
            return slice::slice::Slice{mem: (u8*)"default_shadow_traffic_limit32", size: 30};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum ClusterState {
  Config = 1,
}

export fn ClusterStateUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        ClusterState::Config => {
            next->unpacker = ClusterConfigUnpacker;
            return slice::slice::Slice{mem: (u8*)"config", size: 6};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum TraceRequest {
  Target = 1,
}

export fn TraceRequestUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        TraceRequest::Target => {
            return slice::slice::Slice{mem: (u8*)"target", size: 6};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum TraceShadow {
  Xaddress = 1,
  PublisherCount = 2,
  PublisherSoftLimit = 3,
  PublisherHardLimit = 4,
  TrafficEpoch64 = 5,
  TrafficLimit64 = 6,
}

export fn TraceShadowUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        TraceShadow::Xaddress => {
            return slice::slice::Slice{mem: (u8*)"xaddress", size: 8};
        }
        TraceShadow::PublisherCount => {
            return slice::slice::Slice{mem: (u8*)"publisher_count", size: 15};
        }
        TraceShadow::PublisherSoftLimit => {
            return slice::slice::Slice{mem: (u8*)"publisher_soft_limit", size: 20};
        }
        TraceShadow::PublisherHardLimit => {
            return slice::slice::Slice{mem: (u8*)"publisher_hard_limit", size: 20};
        }
        TraceShadow::TrafficEpoch64 => {
            return slice::slice::Slice{mem: (u8*)"traffic_epoch64", size: 15};
        }
        TraceShadow::TrafficLimit64 => {
            return slice::slice::Slice{mem: (u8*)"traffic_limit64", size: 15};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum TraceResponse {
  Publishing = 1,
  Epoch = 2,
  RxBytes32 = 3,
  TxBytes32 = 4,
  LastSeen = 5,
  FirstSeen = 6,
  Allocation = 7,
  Brokerip = 8,
  PktsSent = 9,
  PktsLost = 10,
  Rtt = 11,
  Alias = 13,
}

export fn TraceResponseUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        TraceResponse::Publishing => {
            next->unpacker = TraceShadowUnpacker;
            return slice::slice::Slice{mem: (u8*)"publishing", size: 10};
        }
        TraceResponse::Epoch => {
            return slice::slice::Slice{mem: (u8*)"epoch", size: 5};
        }
        TraceResponse::RxBytes32 => {
            return slice::slice::Slice{mem: (u8*)"rx_bytes32", size: 10};
        }
        TraceResponse::TxBytes32 => {
            return slice::slice::Slice{mem: (u8*)"tx_bytes32", size: 10};
        }
        TraceResponse::LastSeen => {
            return slice::slice::Slice{mem: (u8*)"last_seen", size: 9};
        }
        TraceResponse::FirstSeen => {
            return slice::slice::Slice{mem: (u8*)"first_seen", size: 10};
        }
        TraceResponse::Allocation => {
            return slice::slice::Slice{mem: (u8*)"allocation", size: 10};
        }
        TraceResponse::Brokerip => {
            return slice::slice::Slice{mem: (u8*)"brokerip", size: 8};
        }
        TraceResponse::PktsSent => {
            return slice::slice::Slice{mem: (u8*)"pkts_sent", size: 9};
        }
        TraceResponse::PktsLost => {
            return slice::slice::Slice{mem: (u8*)"pkts_lost", size: 9};
        }
        TraceResponse::Rtt => {
            return slice::slice::Slice{mem: (u8*)"rtt", size: 3};
        }
        TraceResponse::Alias => {
            return slice::slice::Slice{mem: (u8*)"alias", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum PeerConnectRequest {
  Identity = 1,
  Timestamp = 2,
  Handshake = 3,
  Route = 4,
  Paths = 5,
}

export fn PeerConnectRequestUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        PeerConnectRequest::Identity => {
            return slice::slice::Slice{mem: (u8*)"identity", size: 8};
        }
        PeerConnectRequest::Timestamp => {
            return slice::slice::Slice{mem: (u8*)"timestamp", size: 9};
        }
        PeerConnectRequest::Handshake => {
            return slice::slice::Slice{mem: (u8*)"handshake", size: 9};
        }
        PeerConnectRequest::Route => {
            return slice::slice::Slice{mem: (u8*)"route", size: 5};
        }
        PeerConnectRequest::Paths => {
            next->unpacker = PathUnpacker;
            return slice::slice::Slice{mem: (u8*)"paths", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum PeerConnectResponse {
  Ok = 1,
  Handshake = 2,
  Paths = 3,
  Error = 4,
}

export fn PeerConnectResponseUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        PeerConnectResponse::Ok => {
            return slice::slice::Slice{mem: (u8*)"ok", size: 2};
        }
        PeerConnectResponse::Handshake => {
            return slice::slice::Slice{mem: (u8*)"handshake", size: 9};
        }
        PeerConnectResponse::Paths => {
            next->unpacker = PathUnpacker;
            return slice::slice::Slice{mem: (u8*)"paths", size: 5};
        }
        PeerConnectResponse::Error => {
            return slice::slice::Slice{mem: (u8*)"error", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum ProtoHeader {
  Len = 1,
}

export fn ProtoHeaderUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        ProtoHeader::Len => {
            return slice::slice::Slice{mem: (u8*)"len", size: 3};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export fn EmptyUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Confirmation {
  Ok = 1,
  Error = 2,
}

export fn ConfirmationUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Confirmation::Ok => {
            return slice::slice::Slice{mem: (u8*)"ok", size: 2};
        }
        Confirmation::Error => {
            return slice::slice::Slice{mem: (u8*)"error", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum MoveInstruction {
  Ipaddr = 1,
  Xaddr = 2,
}

export fn MoveInstructionUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        MoveInstruction::Ipaddr => {
            return slice::slice::Slice{mem: (u8*)"ipaddr", size: 6};
        }
        MoveInstruction::Xaddr => {
            return slice::slice::Slice{mem: (u8*)"xaddr", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum InnerTraceRequest {
  Invalid = 1,
  Ping = 2,
}

export fn InnerTraceRequestUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        InnerTraceRequest::Invalid => {
            return slice::slice::Slice{mem: (u8*)"invalid", size: 7};
        }
        InnerTraceRequest::Ping => {
            return slice::slice::Slice{mem: (u8*)"ping", size: 4};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum InnerTraceResponse {
  Invalid = 1,
  Pong = 2,
}

export fn InnerTraceResponseUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        InnerTraceResponse::Invalid => {
            return slice::slice::Slice{mem: (u8*)"invalid", size: 7};
        }
        InnerTraceResponse::Pong => {
            return slice::slice::Slice{mem: (u8*)"pong", size: 4};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum ClaimOne {
  Target = 1,
  Resources = 2,
}

export fn ClaimOneUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        ClaimOne::Target => {
            return slice::slice::Slice{mem: (u8*)"target", size: 6};
        }
        ClaimOne::Resources => {
            return slice::slice::Slice{mem: (u8*)"resources", size: 9};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum ClaimAll {
  Shadow = 1,
  Resources = 2,
}

export fn ClaimAllUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        ClaimAll::Shadow => {
            return slice::slice::Slice{mem: (u8*)"shadow", size: 6};
        }
        ClaimAll::Resources => {
            return slice::slice::Slice{mem: (u8*)"resources", size: 9};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Revoker {
  Identity = 1,
}

export fn RevokerUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Revoker::Identity => {
            return slice::slice::Slice{mem: (u8*)"identity", size: 8};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Claim {
  Opt = 1,
  One = 2,
  All = 3,
  Revoker = 4,
}

export fn ClaimUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Claim::Opt => {
            return slice::slice::Slice{mem: (u8*)"opt", size: 3};
        }
        Claim::One => {
            next->unpacker = ClaimOneUnpacker;
            return slice::slice::Slice{mem: (u8*)"one", size: 3};
        }
        Claim::All => {
            next->unpacker = ClaimAllUnpacker;
            return slice::slice::Slice{mem: (u8*)"all", size: 3};
        }
        Claim::Revoker => {
            next->unpacker = RevokerUnpacker;
            return slice::slice::Slice{mem: (u8*)"revoker", size: 7};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Certificate {
  LastValidEpoch = 1,
  Identity = 2,
  Authority = 3,
  Serial = 4,
  Claims = 5,
}

export fn CertificateUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Certificate::LastValidEpoch => {
            return slice::slice::Slice{mem: (u8*)"last_valid_epoch", size: 16};
        }
        Certificate::Identity => {
            return slice::slice::Slice{mem: (u8*)"identity", size: 8};
        }
        Certificate::Authority => {
            return slice::slice::Slice{mem: (u8*)"authority", size: 9};
        }
        Certificate::Serial => {
            return slice::slice::Slice{mem: (u8*)"serial", size: 6};
        }
        Certificate::Claims => {
            next->unpacker = ClaimUnpacker;
            return slice::slice::Slice{mem: (u8*)"claims", size: 6};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum CertificateRequest {
  LastValidEpoch = 1,
  Identity = 2,
  Claims = 3,
}

export fn CertificateRequestUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        CertificateRequest::LastValidEpoch => {
            return slice::slice::Slice{mem: (u8*)"last_valid_epoch", size: 16};
        }
        CertificateRequest::Identity => {
            return slice::slice::Slice{mem: (u8*)"identity", size: 8};
        }
        CertificateRequest::Claims => {
            next->unpacker = ClaimUnpacker;
            return slice::slice::Slice{mem: (u8*)"claims", size: 6};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Authorization {
  Identity = 1,
  Resource = 2,
}

export fn AuthorizationUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Authorization::Identity => {
            return slice::slice::Slice{mem: (u8*)"identity", size: 8};
        }
        Authorization::Resource => {
            return slice::slice::Slice{mem: (u8*)"resource", size: 8};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum AuthorizationList {
  A = 1,
}

export fn AuthorizationListUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        AuthorizationList::A => {
            next->unpacker = AuthorizationUnpacker;
            return slice::slice::Slice{mem: (u8*)"a", size: 1};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum DiscoveryResponse {
  CarrierRevision = 1,
  CarrierBuildId = 2,
  Application = 3,
  ApplicationVersion = 4,
  Paths = 5,
}

export fn DiscoveryResponseUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        DiscoveryResponse::CarrierRevision => {
            return slice::slice::Slice{mem: (u8*)"carrier_revision", size: 16};
        }
        DiscoveryResponse::CarrierBuildId => {
            return slice::slice::Slice{mem: (u8*)"carrier_build_id", size: 16};
        }
        DiscoveryResponse::Application => {
            return slice::slice::Slice{mem: (u8*)"application", size: 11};
        }
        DiscoveryResponse::ApplicationVersion => {
            return slice::slice::Slice{mem: (u8*)"application_version", size: 19};
        }
        DiscoveryResponse::Paths => {
            return slice::slice::Slice{mem: (u8*)"paths", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Uname {
  Sysname = 1,
  Nodename = 2,
  Release = 3,
  Version = 4,
  Machine = 5,
}

export fn UnameUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Uname::Sysname => {
            return slice::slice::Slice{mem: (u8*)"sysname", size: 7};
        }
        Uname::Nodename => {
            return slice::slice::Slice{mem: (u8*)"nodename", size: 8};
        }
        Uname::Release => {
            return slice::slice::Slice{mem: (u8*)"release", size: 7};
        }
        Uname::Version => {
            return slice::slice::Slice{mem: (u8*)"version", size: 7};
        }
        Uname::Machine => {
            return slice::slice::Slice{mem: (u8*)"machine", size: 7};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Load {
  Avg1 = 1,
  Avg5 = 2,
  Avg15 = 3,
  Clock = 4,
  Uptime = 5,
  Idletime = 6,
  ProcActive = 7,
  ProcTotal = 8,
  Cores = 9,
  Threads = 10,
}

export fn LoadUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Load::Avg1 => {
            return slice::slice::Slice{mem: (u8*)"avg1", size: 4};
        }
        Load::Avg5 => {
            return slice::slice::Slice{mem: (u8*)"avg5", size: 4};
        }
        Load::Avg15 => {
            return slice::slice::Slice{mem: (u8*)"avg15", size: 5};
        }
        Load::Clock => {
            return slice::slice::Slice{mem: (u8*)"clock", size: 5};
        }
        Load::Uptime => {
            return slice::slice::Slice{mem: (u8*)"uptime", size: 6};
        }
        Load::Idletime => {
            return slice::slice::Slice{mem: (u8*)"idletime", size: 8};
        }
        Load::ProcActive => {
            return slice::slice::Slice{mem: (u8*)"proc_active", size: 11};
        }
        Load::ProcTotal => {
            return slice::slice::Slice{mem: (u8*)"proc_total", size: 10};
        }
        Load::Cores => {
            return slice::slice::Slice{mem: (u8*)"cores", size: 5};
        }
        Load::Threads => {
            return slice::slice::Slice{mem: (u8*)"threads", size: 7};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Mem {
  Total = 1,
  Free = 2,
  Available = 3,
}

export fn MemUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Mem::Total => {
            return slice::slice::Slice{mem: (u8*)"total", size: 5};
        }
        Mem::Free => {
            return slice::slice::Slice{mem: (u8*)"free", size: 4};
        }
        Mem::Available => {
            return slice::slice::Slice{mem: (u8*)"available", size: 9};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum FileSystem {
  Path = 1,
  Blocksize = 2,
  Total = 3,
  Free = 4,
}

export fn FileSystemUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        FileSystem::Path => {
            return slice::slice::Slice{mem: (u8*)"path", size: 4};
        }
        FileSystem::Blocksize => {
            return slice::slice::Slice{mem: (u8*)"blocksize", size: 9};
        }
        FileSystem::Total => {
            return slice::slice::Slice{mem: (u8*)"total", size: 5};
        }
        FileSystem::Free => {
            return slice::slice::Slice{mem: (u8*)"free", size: 4};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Firmware {
  Board = 1,
  Distro = 2,
  Release = 3,
  Revision = 4,
  Builder = 5,
  Finger = 6,
  AndroidApiLevel = 7,
}

export fn FirmwareUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Firmware::Board => {
            return slice::slice::Slice{mem: (u8*)"board", size: 5};
        }
        Firmware::Distro => {
            return slice::slice::Slice{mem: (u8*)"distro", size: 6};
        }
        Firmware::Release => {
            return slice::slice::Slice{mem: (u8*)"release", size: 7};
        }
        Firmware::Revision => {
            return slice::slice::Slice{mem: (u8*)"revision", size: 8};
        }
        Firmware::Builder => {
            return slice::slice::Slice{mem: (u8*)"builder", size: 7};
        }
        Firmware::Finger => {
            return slice::slice::Slice{mem: (u8*)"finger", size: 6};
        }
        Firmware::AndroidApiLevel => {
            return slice::slice::Slice{mem: (u8*)"android_api_level", size: 17};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum NetAddress {
  Addr = 1,
  Mask = 2,
  Broadcast = 3,
}

export fn NetAddressUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        NetAddress::Addr => {
            return slice::slice::Slice{mem: (u8*)"addr", size: 4};
        }
        NetAddress::Mask => {
            return slice::slice::Slice{mem: (u8*)"mask", size: 4};
        }
        NetAddress::Broadcast => {
            return slice::slice::Slice{mem: (u8*)"broadcast", size: 9};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Netdev__Duplex {
  Invalid = 0,
  Half = 1,
  Full = 2,
}

export enum Netdev {
  Name = 1,
  RxPkt = 2,
  RxErr = 3,
  TxPkt = 4,
  TxErr = 5,
  Up = 6,
  Macaddr = 7,
  Mtu = 8,
  Addrs = 9,
  Link = 10,
  LinkChanges = 11,
  LinkSpeed = 12,
  LinkDuplex = 13,
}

export fn NetdevUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Netdev::Name => {
            return slice::slice::Slice{mem: (u8*)"name", size: 4};
        }
        Netdev::RxPkt => {
            return slice::slice::Slice{mem: (u8*)"rx_pkt", size: 6};
        }
        Netdev::RxErr => {
            return slice::slice::Slice{mem: (u8*)"rx_err", size: 6};
        }
        Netdev::TxPkt => {
            return slice::slice::Slice{mem: (u8*)"tx_pkt", size: 6};
        }
        Netdev::TxErr => {
            return slice::slice::Slice{mem: (u8*)"tx_err", size: 6};
        }
        Netdev::Up => {
            return slice::slice::Slice{mem: (u8*)"up", size: 2};
        }
        Netdev::Macaddr => {
            return slice::slice::Slice{mem: (u8*)"macaddr", size: 7};
        }
        Netdev::Mtu => {
            return slice::slice::Slice{mem: (u8*)"mtu", size: 3};
        }
        Netdev::Addrs => {
            next->unpacker = NetAddressUnpacker;
            return slice::slice::Slice{mem: (u8*)"addrs", size: 5};
        }
        Netdev::Link => {
            return slice::slice::Slice{mem: (u8*)"link", size: 4};
        }
        Netdev::LinkChanges => {
            return slice::slice::Slice{mem: (u8*)"link_changes", size: 12};
        }
        Netdev::LinkSpeed => {
            return slice::slice::Slice{mem: (u8*)"link_speed", size: 10};
        }
        Netdev::LinkDuplex => {
            return slice::slice::Slice{mem: (u8*)"link_duplex", size: 11};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum SwitchPort {
  Port = 1,
  Link = 2,
  Speed = 3,
  Network = 4,
  Device = 5,
  None = 6,
}

export fn SwitchPortUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        SwitchPort::Port => {
            return slice::slice::Slice{mem: (u8*)"port", size: 4};
        }
        SwitchPort::Link => {
            return slice::slice::Slice{mem: (u8*)"link", size: 4};
        }
        SwitchPort::Speed => {
            return slice::slice::Slice{mem: (u8*)"speed", size: 5};
        }
        SwitchPort::Network => {
            return slice::slice::Slice{mem: (u8*)"network", size: 7};
        }
        SwitchPort::Device => {
            return slice::slice::Slice{mem: (u8*)"device", size: 6};
        }
        SwitchPort::None => {
            return slice::slice::Slice{mem: (u8*)"none", size: 4};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Switch {
  Name = 1,
  Ports = 2,
}

export fn SwitchUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Switch::Name => {
            return slice::slice::Slice{mem: (u8*)"name", size: 4};
        }
        Switch::Ports => {
            next->unpacker = SwitchPortUnpacker;
            return slice::slice::Slice{mem: (u8*)"ports", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Bootloader {
  ActiveSide = 1,
  BootReason = 2,
}

export fn BootloaderUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Bootloader::ActiveSide => {
            return slice::slice::Slice{mem: (u8*)"active_side", size: 11};
        }
        Bootloader::BootReason => {
            return slice::slice::Slice{mem: (u8*)"boot_reason", size: 11};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Belltower {
  Current = 1,
  Previous = 2,
}

export fn BelltowerUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Belltower::Current => {
            return slice::slice::Slice{mem: (u8*)"current", size: 7};
        }
        Belltower::Previous => {
            return slice::slice::Slice{mem: (u8*)"previous", size: 8};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Sysinfo {
  Uname = 1,
  Mem = 2,
  Load = 3,
  Firmware = 4,
  Fs = 5,
  Net = 6,
  Switch = 7,
  BoardId = 8,
  CarrierBuildId = 9,
  Belltower = 10,
  Bootloader = 11,
}

export fn SysinfoUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Sysinfo::Uname => {
            next->unpacker = UnameUnpacker;
            return slice::slice::Slice{mem: (u8*)"uname", size: 5};
        }
        Sysinfo::Mem => {
            next->unpacker = MemUnpacker;
            return slice::slice::Slice{mem: (u8*)"mem", size: 3};
        }
        Sysinfo::Load => {
            next->unpacker = LoadUnpacker;
            return slice::slice::Slice{mem: (u8*)"load", size: 4};
        }
        Sysinfo::Firmware => {
            next->unpacker = FirmwareUnpacker;
            return slice::slice::Slice{mem: (u8*)"firmware", size: 8};
        }
        Sysinfo::Fs => {
            next->unpacker = FileSystemUnpacker;
            return slice::slice::Slice{mem: (u8*)"fs", size: 2};
        }
        Sysinfo::Net => {
            next->unpacker = NetdevUnpacker;
            return slice::slice::Slice{mem: (u8*)"net", size: 3};
        }
        Sysinfo::Switch => {
            next->unpacker = SwitchUnpacker;
            return slice::slice::Slice{mem: (u8*)"switch", size: 6};
        }
        Sysinfo::BoardId => {
            return slice::slice::Slice{mem: (u8*)"board_id", size: 8};
        }
        Sysinfo::CarrierBuildId => {
            return slice::slice::Slice{mem: (u8*)"carrier_build_id", size: 16};
        }
        Sysinfo::Belltower => {
            next->unpacker = BelltowerUnpacker;
            return slice::slice::Slice{mem: (u8*)"belltower", size: 9};
        }
        Sysinfo::Bootloader => {
            next->unpacker = BootloaderUnpacker;
            return slice::slice::Slice{mem: (u8*)"bootloader", size: 10};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum WifiStation {
  Address = 1,
  Inactive = 2,
  RxBytes = 3,
  RxPackets = 4,
  TxBytes = 5,
  TxPackets = 6,
  TxRetries = 7,
  TxFailed = 8,
  BeaconLoss = 9,
  BeaconRx = 10,
  RxDropMisc = 11,
  Signal = 12,
  SignalAvg = 13,
  BeaconSignalAvg = 14,
  TxBitrate = 15,
  RxBitrate = 16,
  RxDuration = 17,
  Expected = 18,
  Authorized = 19,
  Authenticated = 20,
  Associated = 21,
  Preamble = 22,
  Wmm = 23,
  Mfp = 24,
  Tdls = 25,
  Dtim = 26,
  BeaconInterval = 27,
  ShortPreamble = 28,
  ShortSlotTime = 29,
  ConnectedTime = 30,
}

export fn WifiStationUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        WifiStation::Address => {
            return slice::slice::Slice{mem: (u8*)"address", size: 7};
        }
        WifiStation::Inactive => {
            return slice::slice::Slice{mem: (u8*)"inactive", size: 8};
        }
        WifiStation::RxBytes => {
            return slice::slice::Slice{mem: (u8*)"rx_bytes", size: 8};
        }
        WifiStation::RxPackets => {
            return slice::slice::Slice{mem: (u8*)"rx_packets", size: 10};
        }
        WifiStation::TxBytes => {
            return slice::slice::Slice{mem: (u8*)"tx_bytes", size: 8};
        }
        WifiStation::TxPackets => {
            return slice::slice::Slice{mem: (u8*)"tx_packets", size: 10};
        }
        WifiStation::TxRetries => {
            return slice::slice::Slice{mem: (u8*)"tx_retries", size: 10};
        }
        WifiStation::TxFailed => {
            return slice::slice::Slice{mem: (u8*)"tx_failed", size: 9};
        }
        WifiStation::BeaconLoss => {
            return slice::slice::Slice{mem: (u8*)"beacon_loss", size: 11};
        }
        WifiStation::BeaconRx => {
            return slice::slice::Slice{mem: (u8*)"beacon_rx", size: 9};
        }
        WifiStation::RxDropMisc => {
            return slice::slice::Slice{mem: (u8*)"rx_drop_misc", size: 12};
        }
        WifiStation::Signal => {
            return slice::slice::Slice{mem: (u8*)"signal", size: 6};
        }
        WifiStation::SignalAvg => {
            return slice::slice::Slice{mem: (u8*)"signal_avg", size: 10};
        }
        WifiStation::BeaconSignalAvg => {
            return slice::slice::Slice{mem: (u8*)"beacon_signal_avg", size: 17};
        }
        WifiStation::TxBitrate => {
            return slice::slice::Slice{mem: (u8*)"tx_bitrate", size: 10};
        }
        WifiStation::RxBitrate => {
            return slice::slice::Slice{mem: (u8*)"rx_bitrate", size: 10};
        }
        WifiStation::RxDuration => {
            return slice::slice::Slice{mem: (u8*)"rx_duration", size: 11};
        }
        WifiStation::Expected => {
            return slice::slice::Slice{mem: (u8*)"expected", size: 8};
        }
        WifiStation::Authorized => {
            return slice::slice::Slice{mem: (u8*)"authorized", size: 10};
        }
        WifiStation::Authenticated => {
            return slice::slice::Slice{mem: (u8*)"authenticated", size: 13};
        }
        WifiStation::Associated => {
            return slice::slice::Slice{mem: (u8*)"associated", size: 10};
        }
        WifiStation::Preamble => {
            return slice::slice::Slice{mem: (u8*)"preamble", size: 8};
        }
        WifiStation::Wmm => {
            return slice::slice::Slice{mem: (u8*)"wmm", size: 3};
        }
        WifiStation::Mfp => {
            return slice::slice::Slice{mem: (u8*)"mfp", size: 3};
        }
        WifiStation::Tdls => {
            return slice::slice::Slice{mem: (u8*)"tdls", size: 4};
        }
        WifiStation::Dtim => {
            return slice::slice::Slice{mem: (u8*)"dtim", size: 4};
        }
        WifiStation::BeaconInterval => {
            return slice::slice::Slice{mem: (u8*)"beacon_interval", size: 15};
        }
        WifiStation::ShortPreamble => {
            return slice::slice::Slice{mem: (u8*)"short_preamble", size: 14};
        }
        WifiStation::ShortSlotTime => {
            return slice::slice::Slice{mem: (u8*)"short_slot_time", size: 15};
        }
        WifiStation::ConnectedTime => {
            return slice::slice::Slice{mem: (u8*)"connected_time", size: 14};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum WifiInterface {
  Name = 1,
  Typ = 2,
  Phy = 3,
  Ssid = 4,
  Channel = 5,
  Txpower = 6,
  Stations = 7,
}

export fn WifiInterfaceUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        WifiInterface::Name => {
            return slice::slice::Slice{mem: (u8*)"name", size: 4};
        }
        WifiInterface::Typ => {
            return slice::slice::Slice{mem: (u8*)"typ", size: 3};
        }
        WifiInterface::Phy => {
            return slice::slice::Slice{mem: (u8*)"phy", size: 3};
        }
        WifiInterface::Ssid => {
            return slice::slice::Slice{mem: (u8*)"ssid", size: 4};
        }
        WifiInterface::Channel => {
            return slice::slice::Slice{mem: (u8*)"channel", size: 7};
        }
        WifiInterface::Txpower => {
            return slice::slice::Slice{mem: (u8*)"txpower", size: 7};
        }
        WifiInterface::Stations => {
            next->unpacker = WifiStationUnpacker;
            return slice::slice::Slice{mem: (u8*)"stations", size: 8};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum DhcpLease {
  Ts = 1,
  Mac = 2,
  Ip = 3,
  Name = 4,
}

export fn DhcpLeaseUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        DhcpLease::Ts => {
            return slice::slice::Slice{mem: (u8*)"ts", size: 2};
        }
        DhcpLease::Mac => {
            return slice::slice::Slice{mem: (u8*)"mac", size: 3};
        }
        DhcpLease::Ip => {
            return slice::slice::Slice{mem: (u8*)"ip", size: 2};
        }
        DhcpLease::Name => {
            return slice::slice::Slice{mem: (u8*)"name", size: 4};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Arp__HwType {
  Unknown = 0,
  Ethernet = 1,
}

export enum Arp {
  Ip = 1,
  Hw = 2,
  Mac = 3,
  Dev = 4,
  Value = 5,
  Null = 6,
}

export fn ArpUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Arp::Ip => {
            return slice::slice::Slice{mem: (u8*)"ip", size: 2};
        }
        Arp::Hw => {
            return slice::slice::Slice{mem: (u8*)"hw", size: 2};
        }
        Arp::Mac => {
            return slice::slice::Slice{mem: (u8*)"mac", size: 3};
        }
        Arp::Dev => {
            return slice::slice::Slice{mem: (u8*)"dev", size: 3};
        }
        Arp::Value => {
            return slice::slice::Slice{mem: (u8*)"value", size: 5};
        }
        Arp::Null => {
            return slice::slice::Slice{mem: (u8*)"null", size: 4};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum NetRoute {
  Destination = 1,
  Gateway = 2,
  Source = 3,
}

export fn NetRouteUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        NetRoute::Destination => {
            return slice::slice::Slice{mem: (u8*)"destination", size: 11};
        }
        NetRoute::Gateway => {
            return slice::slice::Slice{mem: (u8*)"gateway", size: 7};
        }
        NetRoute::Source => {
            return slice::slice::Slice{mem: (u8*)"source", size: 6};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum NetSurvey {
  Wifi = 1,
  Dhcp = 2,
  Arp = 3,
  Routes = 4,
}

export fn NetSurveyUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        NetSurvey::Wifi => {
            next->unpacker = WifiInterfaceUnpacker;
            return slice::slice::Slice{mem: (u8*)"wifi", size: 4};
        }
        NetSurvey::Dhcp => {
            next->unpacker = DhcpLeaseUnpacker;
            return slice::slice::Slice{mem: (u8*)"dhcp", size: 4};
        }
        NetSurvey::Arp => {
            next->unpacker = ArpUnpacker;
            return slice::slice::Slice{mem: (u8*)"arp", size: 3};
        }
        NetSurvey::Routes => {
            next->unpacker = NetRouteUnpacker;
            return slice::slice::Slice{mem: (u8*)"routes", size: 6};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum LocationAccuracity {
  Hdop = 1,
  Vdop = 2,
  Pdop = 3,
}

export fn LocationAccuracityUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        LocationAccuracity::Hdop => {
            return slice::slice::Slice{mem: (u8*)"hdop", size: 4};
        }
        LocationAccuracity::Vdop => {
            return slice::slice::Slice{mem: (u8*)"vdop", size: 4};
        }
        LocationAccuracity::Pdop => {
            return slice::slice::Slice{mem: (u8*)"pdop", size: 4};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Satellite__Constellation {
  Unknown = 0,
  Galileo = 1,
  Gps = 2,
  Glonass = 3,
}

export enum Satellite {
  Constellation = 1,
  Prn = 2,
  Elevation = 3,
  Azimuth = 4,
  Snr = 5,
  Fix = 6,
}

export fn SatelliteUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Satellite::Constellation => {
            return slice::slice::Slice{mem: (u8*)"constellation", size: 13};
        }
        Satellite::Prn => {
            return slice::slice::Slice{mem: (u8*)"prn", size: 3};
        }
        Satellite::Elevation => {
            return slice::slice::Slice{mem: (u8*)"elevation", size: 9};
        }
        Satellite::Azimuth => {
            return slice::slice::Slice{mem: (u8*)"azimuth", size: 7};
        }
        Satellite::Snr => {
            return slice::slice::Slice{mem: (u8*)"snr", size: 3};
        }
        Satellite::Fix => {
            return slice::slice::Slice{mem: (u8*)"fix", size: 3};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum LocationVelocity {
  Course = 1,
  Speed = 2,
}

export fn LocationVelocityUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        LocationVelocity::Course => {
            return slice::slice::Slice{mem: (u8*)"course", size: 6};
        }
        LocationVelocity::Speed => {
            return slice::slice::Slice{mem: (u8*)"speed", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Location__Fix {
  None = 0,
  Gps = 1,
  DGps = 2,
  Pps = 3,
  Rtk = 4,
  FloatRtk = 5,
  Estimated = 6,
  Manual = 7,
  Simulation = 8,
}

export enum Location {
  Latitude = 1,
  Longitude = 2,
  Altitude = 3,
  Fix = 4,
  Accuracity = 5,
  Satellites = 6,
  Velocity = 7,
}

export fn LocationUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Location::Latitude => {
            return slice::slice::Slice{mem: (u8*)"latitude", size: 8};
        }
        Location::Longitude => {
            return slice::slice::Slice{mem: (u8*)"longitude", size: 9};
        }
        Location::Altitude => {
            return slice::slice::Slice{mem: (u8*)"altitude", size: 8};
        }
        Location::Fix => {
            return slice::slice::Slice{mem: (u8*)"fix", size: 3};
        }
        Location::Accuracity => {
            next->unpacker = LocationAccuracityUnpacker;
            return slice::slice::Slice{mem: (u8*)"accuracity", size: 10};
        }
        Location::Satellites => {
            next->unpacker = SatelliteUnpacker;
            return slice::slice::Slice{mem: (u8*)"satellites", size: 10};
        }
        Location::Velocity => {
            next->unpacker = LocationVelocityUnpacker;
            return slice::slice::Slice{mem: (u8*)"velocity", size: 8};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Sensor__ValueType {
  None = 0,
  MilliCelsius = 1,
}

export enum Sensor {
  Name = 1,
  Vtype = 2,
  Value = 3,
}

export fn SensorUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Sensor::Name => {
            return slice::slice::Slice{mem: (u8*)"name", size: 4};
        }
        Sensor::Vtype => {
            return slice::slice::Slice{mem: (u8*)"vtype", size: 5};
        }
        Sensor::Value => {
            return slice::slice::Slice{mem: (u8*)"value", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum Sensors {
  Sensors = 1,
}

export fn SensorsUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        Sensors::Sensors => {
            next->unpacker = SensorUnpacker;
            return slice::slice::Slice{mem: (u8*)"sensors", size: 7};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export fn NoneUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
    }
    return slice::slice::Slice{mem: 0}; 
}


export fn AuthorizationGetUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum AuthorizationAdd {
  Identity = 1,
  Path = 2,
}

export fn AuthorizationAddUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        AuthorizationAdd::Identity => {
            return slice::slice::Slice{mem: (u8*)"identity", size: 8};
        }
        AuthorizationAdd::Path => {
            return slice::slice::Slice{mem: (u8*)"path", size: 4};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum AuthorizationDel {
  Identity = 1,
}

export fn AuthorizationDelUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        AuthorizationDel::Identity => {
            return slice::slice::Slice{mem: (u8*)"identity", size: 8};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum InteractiveAuth {
  Otp = 1,
}

export fn InteractiveAuthUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        InteractiveAuth::Otp => {
            return slice::slice::Slice{mem: (u8*)"otp", size: 3};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum NetworkJoin {
  Secret = 1,
}

export fn NetworkJoinUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        NetworkJoin::Secret => {
            return slice::slice::Slice{mem: (u8*)"secret", size: 6};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export fn NetworkGetUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum ConfigResult {
  Ok = 1,
  Error = 2,
}

export fn ConfigResultUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        ConfigResult::Ok => {
            return slice::slice::Slice{mem: (u8*)"ok", size: 2};
        }
        ConfigResult::Error => {
            return slice::slice::Slice{mem: (u8*)"error", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum AuthListResult {
  Auth = 1,
}

export fn AuthListResultUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        AuthListResult::Auth => {
            next->unpacker = AuthorizationAddUnpacker;
            return slice::slice::Slice{mem: (u8*)"auth", size: 4};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum NetworkGetResult {
  Address = 2,
}

export fn NetworkGetResultUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        NetworkGetResult::Address => {
            return slice::slice::Slice{mem: (u8*)"address", size: 7};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum GenesisCurrent {
  Sha256 = 1001,
  Commitmsg = 1002,
  Stable = 1003,
  Contentsize = 1004,
}

export fn GenesisCurrentUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        GenesisCurrent::Sha256 => {
            return slice::slice::Slice{mem: (u8*)"sha256", size: 6};
        }
        GenesisCurrent::Commitmsg => {
            return slice::slice::Slice{mem: (u8*)"commitmsg", size: 9};
        }
        GenesisCurrent::Stable => {
            return slice::slice::Slice{mem: (u8*)"stable", size: 6};
        }
        GenesisCurrent::Contentsize => {
            return slice::slice::Slice{mem: (u8*)"contentsize", size: 11};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum GenesisUpdate {
  Sha256 = 1001,
  Commitmsg = 1002,
  Parent = 1003,
  Contentsize = 1004,
}

export fn GenesisUpdateUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        GenesisUpdate::Sha256 => {
            return slice::slice::Slice{mem: (u8*)"sha256", size: 6};
        }
        GenesisUpdate::Commitmsg => {
            return slice::slice::Slice{mem: (u8*)"commitmsg", size: 9};
        }
        GenesisUpdate::Parent => {
            return slice::slice::Slice{mem: (u8*)"parent", size: 6};
        }
        GenesisUpdate::Contentsize => {
            return slice::slice::Slice{mem: (u8*)"contentsize", size: 11};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum OpenHeader__Method {
  Invalid = 0,
  Get = 1,
  Head = 2,
  Post = 3,
  Put = 4,
  Delete = 5,
  Patch = 6,
}

export enum OpenHeader {
  Path = 2,
  Method = 3,
}

export fn OpenHeaderUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        OpenHeader::Path => {
            return slice::slice::Slice{mem: (u8*)"path", size: 4};
        }
        OpenHeader::Method => {
            return slice::slice::Slice{mem: (u8*)"method", size: 6};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


export enum ResponseHeader {
  Status = 1,
  Error = 3,
}

export fn ResponseHeaderUnpacker(usize index, madpack::UnpackSpec mut *next) -> slice::slice::Slice {
    switch index {
        ResponseHeader::Status => {
            return slice::slice::Slice{mem: (u8*)"status", size: 6};
        }
        ResponseHeader::Error => {
            return slice::slice::Slice{mem: (u8*)"error", size: 5};
        }
    }
    return slice::slice::Slice{mem: 0}; 
}


