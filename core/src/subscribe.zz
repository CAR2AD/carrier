using <stdio.h>::{printf};
using <string.h>::{memcpy};
using <assert.h>::{assert};
using err;
using channel;
using router;
using bootstrap;
using io::unix;
using net;
using io;
using time;
using endpoint;
using router;
using hex;
using log;
using pq;
using byteorder;
using identity;
using protonerf;
using stream;
using slice;
using net::address;
using hpack;
using slice::{Slice};
using peering;
using proto;
using noise;
using responder;

static stream::Config Subscribe = stream::Config {
    path:   "/carrier.broker.v1/broker/subscribe",
    stream: on_stream,
    close:  on_close,
};

export fn start(endpoint::Endpoint mut*self, err::Err+et mut*e)
    where err::checked(*e)
{
    stream::Stream mut* streami = self->broker()->open(e, &Subscribe);
    if err::check(e) { return; }
    static_attest(safe(streami));
}

fn on_close(stream::Stream mut *self, err::Err+et mut*e)
    where err::checked(*e)
{
    log::error("subscribe closed\n");
    static_attest(safe(self->chan));
    static_attest(safe(self->chan->endpoint));
    self->chan->endpoint->close();
}

fn on_stream(stream::Stream mut *self, err::Err+et mut*e, Slice bs) -> bool
    where err::checked(*e)
    where slice::slice::integrity(&bs)
{
    static_attest(safe(self->chan));
    if self->state == 0 {
        log::debug("subscribe response headers:");
        new it = hpack::decoder::decode(bs);
        while it.next(e) {
            log::debug("  %.*s: %.*s", it.key.size, it.key.mem, it.val.size, it.val.mem);
        }
        if err::check(e) {
            return false;
        }


        let mut frame = self->chan->q.alloc(e, channel::FrameType::Stream, 100);
        if err::check(e) {
            return false;
        }

        self->state = 1;

        frame.push32(byteorder::to_be32(1)); // stream
        frame.push64(byteorder::to_be64(2)); // order
        frame.push16(0); // size placeholder


        identity::Address mut network ={0};
        static_attest(safe(self->chan));
        static_attest(safe(self->chan->endpoint));
        self->chan->endpoint->vault.get_network(&network);

        protonerf::encode_bytes(frame, e, proto::SubscribeRequest::Shadow, network.k, 32);
        if err::check(e) {
            return false;
        }
    } else if self->state == 1 {
        new iter = protonerf::decode(bs);
        for (protonerf::Field mut field; iter.next(e, &field);) {
            if err::check(e) { return true; }
            if field.a != 0  && field.value.v_len >= 32 {
                static_attest(safe(field.a));
                static_attest(len(field.a) >= field.value.v_len);
                new iter2 = protonerf::decode(slice::slice::Slice { mem: field.a, size: field.value.v_len});
                for (protonerf::Field mut field; iter2.next(e, &field);) {
                    if err::check(e) { return true; }
                    let id = (identity::Identity *)field.a;
                    char mut buf[100] = {0};
                    static_attest(safe(id));
                    identity::identity_to_str(e, buf, static(len(buf)), id);
                    if err::check(e) {
                        e->elog();
                        e->make();
                    }
                    switch field.index {
                        proto::SubscribeChange::Publish => {
                            printf("+ %s\n", buf);
                        }
                        proto::SubscribeChange::Unpublish => {
                            printf("- %s\n", buf);
                        }
                        default => {}
                    }
                }
            }
        }
    }

    return true;
}

