---
title:          'carrier network protocol'
author:         'Arvid E. Picciani (arvid@devguard.io)'
revision:       '1'
date:           'Revision 1, \today'
link-citations: 'true'
geometry:       'margin=4cm'
bibliography:   'bib.bib'
---


# Channels and Messages

Channels are peer to peer encrypted udp pairs similar to wireguard[@WIREGUARD].
They are routed by channel id rather than IP address, allowing a stream to continue seamlessly
when migrating to a different IP address.

A stream of messages is a concept similar to QUIC[@quic-transport-13], except that the message
bounderies are kept intact to support soft-realtime streaming similar to MQTT[@MQTT].

Messages will arrive at the receiver authenticated and in the order they where sent.

# Message broker


a peer on the network can open itself to receiving messages by
signing itself into the global services table.

~~~~~
message AnnounceRequest {
    bytes key = 1;
}
signature
~~~~~

the static key is used to start 0-RTT encryption to the service.
Anyone one the network can send a single message to service,
which is already encrypted. This allows for command and control
servers to be stateless (for example PHP websites).
This is the equivalent of QOS level 0 in MQTT.


TODO:
IoT systems are usuually vastly less powereful than a server on the
internet, making it vulternable to DoS if anyone on the internet
could send it messages. To create power-equilibrium, a stake
needs to be included by the sender.


# Cryptosystem

## Handshake

A simple Diffie-Hellman Key exchange is done before messages can be transported,
based on the the Noise Protocol Framework [@NOISE].

We build on wireguard[@WIREGUARD]'s idea of not sending responses to unauthenticated packages
by using the noise NK pattern. An inititor has to obtain the responders static key
from a side channel first before sending the first packet.

Unlike wireguard, we do not use a static key for the initiator, because its identity is established
using signatures instead. The signatures are sent in the first message, somewhat weakening forward secrecy
for when the responders static key is stolen. For this reason, the first message only contains identity
signatures. An attacker will only be able to make out which identity connected, but not for what purpose.
This is identical to wireguard, which uses the X25519 key as identity instead.

If u describes an Ed25519 identity and u(h) a signature over the session hash, The pattern is as follows:


~~~~~
NKSig:
  <- s
  ...
  -> e, es, [u, u(h), t]
  <- e, ee
~~~~~


The initiator starts by sending its identity and a semi-static x25519
which is generated before boot, and then signed by its actual ed25519 identity.
This is done, so that the ed25519 secret can be kept offline.
If a semi-static exchange identity is compromised, the offline key can be used
to generate a new one with a new serial number.

A serial number is any integer that always must go up for the lifetime
of the offline identity. The responder keeps track of this number per
identity and rejects any handshake that does not increase it.
This prevents both replay attacks as well as using stolen keys.

The serial does not actually have to be based on a clock,
as long as the sender guarantees that it always goes up, even after reboot.
The network will keep a distributed append-only log of that number.

The epoch should however be synchronized with the network ocassionally,
since at some point we might want to purge the log of used identities.
Any identity before the cutoff epoch will be invalid.

## Packet Format

### from initiator to responder:

The first message from the initiator is different in that the Receiver is set to zero.
This is the equivalent of SYN, i.e. opening a new transport channel.

Note that the packet counter is not nessesarily 1. It may be higher if
earlier handshake packages are lost.

~~~~~
--------------------------------------------------------
| Vers = 0x08 (1 byte) | Reserved = 0xffffff (3 bytes) |
--------------------------------------------------------
| Receiver Channel = 0x00000000 (8 bytes)              |
--------------------------------------------------------
| Sender Channel =  Random (8 bytes)                   |
--------------------------------------------------------
| Packet Counter = 1 (8 bytes)                         |
--------------------------------------------------------
| Ephermal (32 bytes)                                  |
--------------------------------------------------------
| Semi-Static (32 bytes)                               |
--------------------------------------------------------
| Authentication Tag (12 bytes)                        |
--------------------------------------------------------
             ------ encrypted ----

--------------------------------------------------------
| Semi-Static (32 bytes)                               |
--------------------------------------------------------
| Identity (32 bytes)                                  |
--------------------------------------------------------
| Epoch (1 Byte unsigned)                              |
--------------------------------------------------------
| Serial (4 Bytes unsigned big endian)                 |
--------------------------------------------------------
| Signature (64 bytes)                                 |
--------------------------------------------------------

--------------------------------------------------------
| Padding to 255 bytes boundary                        |
--------------------------------------------------------
~~~~~


**Packet Counter**

8 byte big-endian integer that increases for each sent packet. it is never reused and each
new packet must always have a packet counter higher than the previous packet.

The packet counter is for replay-mitigation based on Appendix C of RFC2401[@RFC2401].

It is also used for measuring packet loss. Packets are never resent, instead reordering
is done based on individual stream counters.


TODO: quic uses 32bit, this seems rather small.

### from responder to initiator:

transport looks identical in plaintext to a handshake response.
When packet reordering occures on the wire, this would lead an initiator
to decode a transport message as handshake, and therefor
taking random ciphertext as ephermal.

This is already mitigated by waiting for the application header.


~~~~~
--------------------------------------------------------
| Vers = 0x08 (1 byte) | Reserved = 0xffffff (3 bytes) |
--------------------------------------------------------
| Receiver Channel = Initiator (8 bytes)               |
--------------------------------------------------------
| Packet Counter  = 1 (bytes unsigned big endian)      |
--------------------------------------------------------
| Ephermal (32 bytes)                                  |
--------------------------------------------------------
| Authentication Tag (12 bytes)                        |
--------------------------------------------------------
             ------ encrypted ----
--------------------------------------------------------
| Sender Channel =  Random (8 bytes)                   |
--------------------------------------------------------
| Identity (32 bytes)                                  |
--------------------------------------------------------
| Epoch (1 Byte unsigned)                              |
--------------------------------------------------------
| Serial (4 Bytes unsigned big endian)                 |
--------------------------------------------------------
| Signature (64 bytes)                                 |
--------------------------------------------------------
| Padding to 255 bytes boundary                        |
--------------------------------------------------------
~~~~~

### in transport mode

~~~~~
--------------------------------------------------------
| Vers = 0x08 (1 byte) | Reserved = 0xffffff (3 bytes) |
--------------------------------------------------------
| Receiver Channel (8 bytes)                           |
--------------------------------------------------------
| Packet Counter  = 2 (bytes unsigned big endian)      |
--------------------------------------------------------
| Authentication Tag (12 bytes)                        |
--------------------------------------------------------
             ------ encrypted ----
--------------------------------------------------------
| Frame 1                                              |
--------------------------------------------------------
| Frame 2                                              |
--------------------------------------------------------
| Frame ..                                             |
--------------------------------------------------------
| Padding to 255 bytes boundary                        |
--------------------------------------------------------
~~~~~



## Frame types

TODO: implement stream multiplexing

| Value | name       |
|-------|------------|
| 0x00  | Padding    |
| 0x01  | Ack        |
| 0x02  | Ping       |
| 0x03  | Disconnect |
| 0x05  | Message    |
| 0x06  | Close      |

### 0x00 Padding

Padding in the form of 0x00 bytes can ocure before a frame header,
or after a completed frame and must be skipped until there is a value
that is not 0x00 (the next useful frame header).

### 0x01 Ack

~~~~~
--------------------------------------------------------
| Frame Type = 0x01 (1 byte)                           |
--------------------------------------------------------
| Ack Delay = delay in ms (2 byte unsigned big endian) |
--------------------------------------------------------
| Ack Count (2 byte unsigned big endian)               |
--------------------------------------------------------
| Ack 1   (8 bytes unsigned big endian)                |
--------------------------------------------------------
| Ack 2   (8 bytes unsigned big endian)                |
--------------------------------------------------------
| Ack ..  (8 bytes unsigned big endian)                |
--------------------------------------------------------
~~~~~

the acks are sorted by largest first

### 0x02 Ping
~~~~~
--------------------------------------------------------
| Frame Type = 0x02 (1 byte)                           |
--------------------------------------------------------
~~~~~

### 0x03 Disconnect

~~~~~
--------------------------------------------------------
| Frame Type = 0x03 (1 byte)                           |
--------------------------------------------------------
| Order (8 bytes unsigned big endian)                  |
--------------------------------------------------------
~~~~~

Tells the other side to stop sending any packets.
Also stop resending unacked, since the peer is no longer
available.


### 0x05 Message

~~~~~
--------------------------------------------------------
| Frame Type = 0x05 (1 byte)                           |
--------------------------------------------------------
| Order (8 bytes unsigned big endian)                  |
--------------------------------------------------------
| Data Size (2 byte unsigned big endian)               |
--------------------------------------------------------
| Data                                                 |
--------------------------------------------------------
~~~~~


### 0x06 Close

~~~~~
--------------------------------------------------------
| Frame Type = 0x05 (1 byte)                           |
--------------------------------------------------------
| Order (8 bytes unsigned big endian)                  |
--------------------------------------------------------
~~~~~

This is the last message in a stream. The sender may still
be open to receiving Messages but will not send any new ones.

Close Messages must be delivered to the application in order,
so that any preceeding data is handled first.

# References



