using err;
using bootstrap;
using vault;
using io::unix;
using net;
using endpoint;
using publish as publishing;
using identity_kit;
using <string.h>::{memset, memcpy};
using io;
using identity;
using time;
using bootstrap;
using net;
using endpoint;
using log;

export struct Mission+ {
    io::unix::Async+100 mut async;
    endpoint::Endpoint+ mut ep;
}

export fn start(Mission+mt mut new * self, err::Err+et mut *e, identity::Identity * unsafe cluster_target)
    where err::checked(*e)
    where mt > mt/32
{

    io::unix::make(&self->async);

    endpoint::from_carriertoml(&self->ep, e);
    if err::check(e) { return ; }

    /*
    self->vault.broker[0] = vault::Broker {
        protocol:   0x09,
        ip4addr:    {127,0,0,1},
    };
    identity::address_from_cstr((identity::Address mut*)&self->vault.broker[0].xaddr, e, "oSaoKYLdcdqGAJPkt3scwP2H8FuEy58GjT59LwpigL4y7h9");
    e->abort();
    */

    bootstrap::sync(e, &self->ep.vault, net::os(), &self->async, time::from_seconds(10));
    if err::check(e) { return ; }

    self->ep.start(e, net::os(), &self->async);
    if err::check(e) { return ; }

    if cluster_target != 0 {
        unsafe {
            endpoint::cluster_target(&self->ep, mt, cluster_target);
        }
    }

    io::await(&self->async, e, endpoint::poll, &self->ep, time::from_seconds(30));
    if err::check(e) { return ; }
}

export fn run(Mission+mt mut *self, err::Err+et mut *e)
    where err::checked(*e)
{
    io::await(&self->async, e, endpoint::poll, &self->ep, time::infinite());
    if err::check(e) { return ; }
}


export fn close(Mission mut *self)
{
    self->ep.close();
}

