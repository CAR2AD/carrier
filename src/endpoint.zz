using <stdio.h>::{printf};
using <string.h>::{memset, memcpy};
using string;
using net::address;
using err;
using byteorder;
using net::udp;
using time;
using bootstrap;
using identity;
using initiator;
using io;
using net;
using cipher;
using hex;
using channel;
using router;
using peering;
using log;
using pool;
using slice;
using hpack;
using stream;
using protonerf;
using proto;
using noise;
using responder;
using peering;
using vault;
using vault_toml;

export const char* PROLOGUE = "carrier has arrived";
export const char* SIGN_PURPOSE = "carrier handshake hash 1";


inline using (needs
    vault::Vault,
    Endpoint,
    err::Err,
) "endpoint.h"::{
    os_carrier_endpoint_open,
};


export symbol InvalidBootstrap;

const usize RETRY_EACH_BROKER = 5;

enum State {
    Invalid,
    Connecting,
    Connected,
    Closed,
}

struct ConnectingState {
    vault::Broker           mut current_broker;
    initiator::Initiator    mut initiator;
    string::String+1024     mut pkt_in;
    string::String+1024     mut pkt_out;
    usize trying_broker_index;
    usize retry_sending;
}

union StateM {
    ConnectingState         connecting;
    router::Router          connected;
}

export struct Endpoint+ {
    net::Engine*            netengine;
    vault::Vault            vault;

    initiator::Move         cluster_move;
    identity::Identity      cluster_target;

    stream::Config *        broker_stream_registry[2];
    stream::Config *        p2p_stream_registry[32];

    udp::Socket     mut udp4;
    udp::Socket     mut udp6;
    io::Io          mut timeout;

    State           mut state;
    StateM          mut statem;

    pool::Pool+1024 mut streampool;
    pool::Pool+     mut framebuffer;
}

export fn start(Endpoint mut* self, err::Err+et mut*e, net::Engine *netengine, io::Async mut* async)
    where err::checked(*e)
{
    self->netengine = netengine;
    self->state = State::Connecting;
    self->do_state_connect(e, async);
}

export fn none(Endpoint+xt mut new* self)
    where xt > xt/32
{
    memset(self, 0, sizeof(Endpoint));
    self->streampool.make(sizeof(stream::Stream));
    self->framebuffer.make(32);
}

export fn from_carriertoml(Endpoint+xt mut new* self, err::Err+et mut*e, char *file_name)
    where err::checked(*e)
    where xt > xt/32
    where nullterm(file_name)
{
    none(self);
    vault_toml::from_carriertoml(&self->vault, e, file_name);
}

export fn from_home_carriertoml(Endpoint+xt mut new* self, err::Err+et mut*e)
    where err::checked(*e)
    where xt > xt/32
{
    none(self);
    vault_toml::from_home_carriertoml(&self->vault, e);
}

export fn native(Endpoint+xt mut new* self, err::Err+et mut*e)
    where err::checked(*e)
    where xt > xt/32
{
    none(self);
    os_carrier_endpoint_open(self, e, et);
}

export fn from_vault(Endpoint+xt mut new* self, err::Err+et mut*e, vault::Vault vault)
    where err::checked(*e)
    where xt > xt/32
{
    none(self);
    self->vault = vault;
}

export fn broker(Endpoint mut* self) -> channel::Channel mut *
    model safe(return)
{
    return &self->statem.connected.channels[0];
}

export fn cluster_target(Endpoint mut* self, identity::Identity * target)
{
    memcpy(&self->cluster_target, target, sizeof(identity::Identity));
    self->cluster_move = initiator::Move::Target;
}

//TODO send disconnect packet
export fn close(Endpoint mut* self)
{
    switch self->state {
        State::Connecting => {
            self->udp4.close();
            self->udp6.close();
        }
        State::Connected => {
            self->statem.connected.close();
        }
        default => {
        }
    }
    self->state = State::Closed;
    if self->vault.i_close != 0 {
        static_attest(safe(self->vault.i_close));
        self->vault.i_close(&self->vault);
    }
}

export fn register_stream(Endpoint mut* self, stream::Config *conf)
{
    for (usize mut i = 0; i < static(len(self->p2p_stream_registry)); i++) {
        if self->p2p_stream_registry[i] == 0 {
            self->p2p_stream_registry[i] = conf;
            return;
        }
    }
}



fn next_broker(Endpoint mut* self) -> bool
{
    for (usize mut i = 0; i < vault::MAX_BROKERS; i++) {
        if self->statem.connecting.trying_broker_index >= vault::MAX_BROKERS {
            self->statem.connecting.trying_broker_index = 0;
        }
        static_attest(self->statem.connecting.trying_broker_index < len(self->vault.broker));
        if self->vault.broker[self->statem.connecting.trying_broker_index].protocol != 0 {
            log::debug("loading broker slot %zu", self->statem.connecting.trying_broker_index);
            memcpy(&self->statem.connecting.current_broker,
                &self->vault.broker[self->statem.connecting.trying_broker_index],
                sizeof(vault::Broker));
            self->statem.connecting.trying_broker_index += 1;
            return true;
        }
        self->statem.connecting.trying_broker_index += 1;
    }
    return false;
}

static u16 PORTS[] = {53, 443, 8443, 80, 123};




fn do_state_connect(Endpoint mut* self, err::Err+et mut*e, io::Async mut* async)
    where err::checked(*e)
{
    log::info("trustvector complete, ring has %zu brokers", self->vault.broker_count());

    self->state = State::Connecting;
    memset(&self->statem.connecting, 0, sizeof(ConnectingState));

    static_attest(safe(self->netengine));
    new addr4 = address::from_cstr("0.0.0.0:0");
    net::udp(&self->udp4, self->netengine, e, &addr4, async);
    if err::check(e) {
        return;
    }

    new addr6 = address::from_cstr("[::1]:0");
    net::udp(&self->udp6, self->netengine, e, &addr6, async);
    if err::check(e) {
        return;
    }

    if !self->next_broker(){
        err::fail(e, InvalidBootstrap, "no brokers in bootstrap store");
        return;
    }
}

export fn poll(Endpoint mut* self, err::Err+et mut*e, io::Async mut* async) -> io::Result
    where err::checked(*e)
{
    switch self->state {
        // TODO retry timeout
        State::Connecting => {

            // make sure we always activate
            if io::valid(&self->timeout) {
                async->select(e, &self->timeout, io::Ready::Read);
                if err::check(e) {return io::Result::Error; }
            }
            if io::valid(&self->udp4) {
                async->select(e, &self->udp4, io::Ready::Read);
                if err::check(e) {return io::Result::Error; }
            }
            if io::valid(&self->udp6) {
                async->select(e, &self->udp6, io::Ready::Read);
                if err::check(e) {return io::Result::Error; }
            }

            // receive
            address::Address    mut fromaddr = {0};
            self->statem.connecting.pkt_in.clear();
            if self->udp4.recvfrom(e, &self->statem.connecting.pkt_in, &fromaddr) == io::Result::Ready {
                err::make(e);

                string::String+100 mut bufx = {0};
                fromaddr.to_string(&bufx);
                log::debug("receiving %zu bytes from %s", self->statem.connecting.pkt_in.len, bufx.mem);

                channel::Channel  mut broker_chan = {0};
                vault::Broker mut redir = {0};
                self->statem.connecting.initiator.complete(e, &broker_chan, &redir, &self->statem.connecting.pkt_in, 0);
                if err::check(e) {
                    e->elog();
                    err::make(e);
                    // don't return here. we might have stuff to set the timer in the rest of the code
                } else if redir.protocol != 0 {
                    log::debug("received redirect");
                    memcpy(&self->statem.connecting.current_broker, &redir, sizeof(vault::Broker));
                    self->statem.connecting.retry_sending = 0;
                    self->timeout.close();
                    return self->poll(e, async);
                } else {
                    log::debug("accepted HS");
                    self->state = State::Connected;
                    memset(&self->statem , 0, sizeof(StateM));

                    broker_chan.peering.received(peering::Transport::Udp, fromaddr, peering::Class::Internet);
                    broker_chan.q.allocator = &self->framebuffer;
                    broker_chan.store  = &self->vault;
                    broker_chan.this_is_the_broker_channel = true;
                    broker_chan.errors_are_fatal = true;

                    self->statem.connected  = router::make(broker_chan, self->udp4, self->udp6);
                    self->statem.connected.channels[0].endpoint = self;

                    return io::Result::Ready;
                }
                err::make(e);
            }
            if err::check(e) {return io::Result::Error; }

            // or timeout

            if self->timeout.valid() {
                u8 mut buf[16];
                usize mut l = 16;
                io::Result rr = self->timeout.read_bytes(e, buf, &l);
                if err::check(e) {return io::Result::Error; }
                if rr != io::Result::Ready {
                    return rr;
                }
                log::warn("timeout waiting for broker response");
            }
            self->timeout.close();

            usize mut wait = 0;
            switch self->statem.connecting.retry_sending {
                0       => { wait = 100  }
                1       => { wait = 200  }
                2       => { wait = 400  }
                3       => { wait = 1000 }
                default => { wait = 2000 }
            }

            self->timeout = io::timeout(async, e, time::from_millis(wait));
            if err::check(e) {return io::Result::Error; }
            async->select(e, &self->timeout, io::Ready::Read);
            if err::check(e) {return io::Result::Error; }

            if self->statem.connecting.retry_sending > 6 {
                self->statem.connecting.retry_sending = 0;
                self->next_broker();
            }

            // TODO: abstract
            // TODO: this is stupid in the first place. the protocol needs a different replay protection
            //time::Time now = time::real();
            //self->vault.mem->time = now.to_millis();



            address::Address  mut ip4addr = {0};
            address::Address  mut ip6addr = {0};
            identity::Address mut xaddr   = {0};

            if !bootstrap::from_store(&self->statem.connecting.current_broker, &ip4addr, &ip6addr, &xaddr) {
                err::fail(e, InvalidBootstrap, "current broker is empty");
                return io::Result::Error;
            }

            if self->statem.connecting.retry_sending % 3 == 0 {
                log::debug("resetting crypto state");

                self->statem.connecting.initiator.initiate(
                    e,
                    true,
                    &self->vault,
                    self->cluster_move,
                    &self->cluster_target,
                    &xaddr,
                    self->vault.vector_time(),
                    &self->statem.connecting.pkt_out
                );
                if err::check(e) {return io::Result::Error;}
            }

            string::String+150 mut dbn = {0};
            ip4addr.ip_to_string(&dbn);
            dbn.append_cstr(" ");
            static_attest(len(&dbn.mem) > dbn.len);
            dbn.len += identity::address_to_str(e, dbn.mem + dbn.len, 150 - dbn.len, &xaddr);
            if err::check(e) {return io::Result::Error; }

            log::debug("attempt %zu sending %zu bytes to %.*s",
                self->statem.connecting.retry_sending,
                self->statem.connecting.pkt_out.len,
                (int)dbn.len, dbn.mem);

            ++self->statem.connecting.retry_sending;

            for (usize mut i = 0; i < static(len(PORTS));i++) {
                ip4addr.set_port(PORTS[i]);
                ip6addr.set_port(PORTS[i]);

                self->udp4.sendto(e, &self->statem.connecting.pkt_out, &ip4addr);
                err::make(e);

                if io::valid(&self->udp6) && ip6addr.valid() {
                    self->udp6.sendto(e, &self->statem.connecting.pkt_out, &ip6addr);
                    err::make(e);
                }
           }


            async->select(e, &self->udp4, io::Ready::Read);


            return io::Result::Later;
        }
        State::Connected => {
            return self->statem.connected.poll(e, async);
        }
        State::Closed => {
            log::debug("quitting time");
            return io::Result::Ready;
        }
        State::Invalid => {}
    }

    return io::Result::Later;
}
