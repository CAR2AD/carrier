using err;
using identity;
using identity_kit;
using <stdio.h>::{printf, fopen, fclose, fread, FILE, fgetc, EOF};
using <string.h>::{memcpy, memset};

export const usize MAX_BROKERS = 16;

export struct Broker packed {
    u8 protocol;
    u8 reserved[3];
    u8 xaddr[32];
    u8 ip4addr[4];
    u8 ip6addr[16];
}

export struct Vault {
    u8  version;
    u8  secret[32];
    u64 time;
    Broker broker[MAX_BROKERS];
}

export fn empty(Vault mut new *self) {
    self->version =  1;
}

export fn load_ik(Vault mut *self, err::Err+et mut * e, identity_kit::IdentityKit *ik)
    where err::checked(*e)
{
    //TODO principal != identity secret
    memcpy(self->secret, ik->principal.k, 32);
}

export fn get_identity(Vault * self, identity::Identity mut*id) {
    identity::identity_from_secret(id, (identity::Secret*)&self->secret);
}

export fn broker_count(Vault * self) -> usize {
    usize mut c = 0;
    for (usize mut i = 0; i < MAX_BROKERS; i++) {
        if self->broker[i].protocol != 0 {
            c++;
        }
    }
    return c;
}


using toml;
using fs;
using string;

export fn from_carriertoml(Vault mut new *self, err::Err+et mut *e)
    where err::checked(*e)
{
    self->version =  1;

    new+1000 parser = toml::parser(e, (toml::deserialize_t)load_from_toml_cb, self);
    if err::check(e) {return;}

    string::String+300 mut ff;
    ff.clear();
    fs::get_homedir(e, &ff);
    if err::check(e) {return;}
    ff.append_cstr("/.devguard/carrier.toml");

    let f = (FILE mut*)fopen(ff.mem, "r");
    if f == 0 {
        err::fail_with_errno(e, "open %s", ff.mem);
        return;
    }

    char mut buf[300];
    for(;;) {
        usize bin = as<usize>(fread(buf, sizeof(char), static(len(buf)), f));
        if bin == 0 {
            break;
        }
        static_attest(bin < len(buf));
        toml::push(&parser, e, buf, bin);
        if err::check(e) { fclose(f); return; }
    }

    fclose(f);
}

fn load_from_toml_cb(err::Err+et mut *e, toml::Parser+pt mut* p, void mut *user, char *k, toml::Value v)
    where err::checked(*e)
{
    let store = (Vault mut*)user;
    static_attest(safe(store));
    static_attest(nullterm(v.string));
    static_attest(nullterm(k));
    static_attest(safe(v.string));
    if v.t == toml::ValueType::String && string::cstr_eq(k, "secret") {
        identity::secret_from_cstr((identity::Secret mut*)&store->secret, e, v.string);
    }
}

