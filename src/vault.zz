using err;
using endpoint;
using identity;
using identity_kit;
using <stdio.h>::{printf};
using <string.h>::{memcpy, memset};

export const usize MAX_BROKERS = 16;

export struct Broker packed {
    u8 protocol;
    u8 reserved[3];
    u8 xaddr[32];
    u8 ip4addr[4];
    u8 ip6addr[16];
}

export struct Vault {
    u8  version;
    u8  secret[32];
    u64 time;
    Broker broker[MAX_BROKERS];
}

export fn empty(Vault mut new *self) {
    self->version =  1;
}

export fn from_identity_kit(Vault mut new *self, err::Err+et mut * e, identity_kit::IdentityKit *ik)
    where err::checked(*e)
{
    self->version = 1;

    //TODO principal != identity secret
    memcpy(self->secret, ik->principal.k, 32);
}

export fn get_identity(Vault * self, identity::Identity mut*id) {
    identity::identity_from_secret(id, (identity::Secret*)&self->secret);
}

export fn broker_count(Vault * self) -> usize {
    usize mut c = 0;
    for (usize mut i = 0; i < MAX_BROKERS; i++) {
        if self->broker[i].protocol != 0 {
            c++;
        }
    }
    return c;
}
