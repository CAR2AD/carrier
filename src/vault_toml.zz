using toml;
using err;
using vault;
using fs;
using string;
using identity;
using <stdio.h>::{fopen, fclose, fread, FILE, fgetc, EOF, fprintf, stderr, fputc};
using <string.h>::{memcpy, memset};
using <stdlib.h>::{malloc, free};
using log;
using time;

struct Authorize {
    bool used;
    identity::Identity identity;
    string::String+300 mut path;
}

struct Mem {
    identity::Secret secret;
    identity::Address network;
    identity::Secret network_secret;

    Authorize auth[32];
    string::String+2000 mut file_name;
}

export fn from_home_carriertoml(vault::Vault mut new *self, err::Err+et mut *e)
    where err::checked(*e)
{
    new+200 s = string::make();
    fs::get_homedir(e, &s);
    if err::check(e) {return;}
    s.append_cstr("/.devguard/carrier.toml");
    from_carriertoml(self, e, s.cstr());
}

fn close(vault::Vault mut*self) {
    if self->user != 0 {
        free(self->user);
        self->user = 0;
    }
}

export fn from_carriertoml(vault::Vault mut new *self, err::Err+et mut *e, char * file_name)
    where err::checked(*e)
    where nullterm(file_name)
{
    memset(self, 0, sizeof(vault::Vault));

    self->i_get_secret           = i_get_secret;
    self->i_get_network          = i_get_network;
    self->i_advance_clock        = i_advance_clock;
    self->i_set_network          = i_set_network;
    self->i_list_authorizations  = i_list_authorizations;
    self->i_del_authorization    = i_del_authorization;
    self->i_add_authorization    = i_add_authorization;
    self->i_close                = close;


    self->user = malloc(sizeof(Mem));
    Mem mut * this = (Mem mut *)self->user;
    memset(this, 0, sizeof(Mem));
    static_attest(safe(this));

    new+1000 parser = toml::parser(e, toml::U{
        it: load_from_toml_cb,
        user1: this
    });
    if err::check(e) {return;}

    this->file_name.clear();
    this->file_name.append_cstr(file_name);

    let mut f = (FILE mut*)fopen(this->file_name.cstr(), "r");
    if f == 0 {
        f = (FILE mut*)fopen(this->file_name.cstr(), "w");
        if f == 0 {
            err::fail_with_errno(e, "open %s", this->file_name.cstr());
            return;
        }
        identity::secret_generate (&this->secret, e);
        if err::check(e) {fclose(f); return;}
        identity::secret_generate (&this->network_secret, e);
        if err::check(e) {fclose(f); return;}
        identity::address_from_secret(&this->network, &this->network_secret);

        save_to_toml(this, e);
        if err::check(e) {fclose(f); return;}
        log::info("created %s\n", this->file_name.cstr());
    }

    char mut buf[300];
    for(;;) {
        usize bin = as<usize>(fread(buf, sizeof(char), static(len(buf)), f));
        if bin == 0 {
            break;
        }
        static_attest(bin < len(buf));
        parser.push(e, buf, bin);
        if err::check(e) { fclose(f); return; }
    }

    parser.close(e);
    if err::check(e) { fclose(f); return; }

    fclose(f);

    identity::nullcheck(e, this->network.k);
    if err::check(e) { return; }

    identity::nullcheck(e, this->secret.k);
    if err::check(e) { return; }

}


fn load_from_toml_cb_publish(toml::U *u, err::Err+et mut *e, toml::Parser+pt mut* p, char *k, toml::Value v)
    where err::checked(*e)
    where nullterm(k)
{
    let this = (Mem mut*)u->user1;
    static_attest(safe(this));

    if string::cstr_eq(k, "shadow") || string::cstr_eq(k, "address") {
        err::assert_safe(v.string);
        static_attest(nullterm(v.string));
        identity::address_from_cstr (&this->network, e, v.string);
        if err::check(e) { return; }
    } else if string::cstr_eq(k, "secret") {
        err::assert_safe(v.string);
        static_attest(nullterm(v.string));
        identity::secret_from_cstr (&this->network_secret, e, v.string);
        if err::check(e) { return; }
    }
}

fn load_from_toml_authorize_iter(toml::U *self, err::Err+et mut *e, toml::Parser+pt mut* p, char *k, toml::Value v)
    where err::checked(*e)
    where nullterm(k)
{
    let this = (Mem mut*)self->user1;
    static_attest(safe(this));

    static_attest(self->user2 < len(this->auth));
    Authorize mut *a = this->auth + self->user2;

    if string::cstr_eq(k, "identity") {
        err::assert_safe(v.string);
        static_attest(nullterm(v.string));
        identity::identity_from_cstr (
            &a->identity,
            e,
            v.string
        );
        if err::check(e) { return; }
    } else if string::cstr_eq(k, "resource") {
        a->path.clear();
        a->path.append_cstr(v.string);
    }

    if !identity::isnull(a->identity.k) && a->path.slen() > 0 {
        a->used = true;
    }
}

fn load_from_toml_cb(toml::U *u, err::Err+et mut *e, toml::Parser+pt mut* p, char *k, toml::Value v)
    where err::checked(*e)
    where nullterm(k)
{

    let this = (Mem mut*)u->user1;
    static_attest(safe(this));
    static_attest(nullterm(v.string));
    static_attest(nullterm(k));
    static_attest(safe(v.string));

    if string::cstr_eq(k, "publish") && v.t == toml::ValueType::Object {
        toml::next(p, e, toml::U{it: load_from_toml_cb_publish, user1: this});
    } else if string::cstr_eq(k, "network") && v.t == toml::ValueType::Object {
        toml::next(p, e, toml::U{it: load_from_toml_cb_publish, user1: this});
    } else if string::cstr_eq(k, "authorize") && v.t == toml::ValueType::Object {
        for (usize mut i = 0; i < static(len(this->auth)); i++) {
            if !this->auth[i].used {
                toml::next(p, e, toml::U{
                    it:     load_from_toml_authorize_iter,
                    user1:  this,
                    user2:  i,
                });
                break;
            }
        }
    } else if v.t == toml::ValueType::String && string::cstr_eq(k, "secret") {
        identity::secret_from_cstr((identity::Secret mut*)&this->secret, e, v.string);
    }
}




fn save_to_toml(Mem *self, err::Err+et mut *e)
    where err::checked(*e)
{
    let out = (FILE mut*)fopen(self->file_name.cstr(), "w");
    if out == 0 {
        err::fail_with_errno(e, "open %s", self->file_name.cstr());
        return;
    }

    char mut buf[120] = {0};
    identity::secret_to_str(e, buf, static(len(buf)), (identity::Secret*)&self->secret);
    if err::check(e) { fclose(out); return; }
    fprintf(out , "secret = \"%s\"\n", buf);


    if !identity::isnull(self->network.k) {
        identity::address_to_str(e, buf, static(len(buf)), &self->network);
        if err::check(e) { fclose(out); return; }
        fprintf(out , "\n[network]\naddress = \"%s\"\n", buf);

        if !identity::isnull(self->network_secret.k) {
            identity::secret_to_str(e, buf, static(len(buf)), &self->network_secret);
            if err::check(e) { fclose(out); return; }
            fprintf(out, "secret = \"%s\"\n", buf);
        }
    }

    for (usize mut i = 0; i < static(len(self->auth)); i++) {
        if !self->auth[i].used {
            continue;
        }
        identity::identity_to_str(e, buf, static(len(buf)), &self->auth[i].identity);
        fprintf(out , "\n[[authorize]]\nidentity = \"%s\"\nresource = \"", buf);
        fprintf(out , "\"%.*s\"\n", self->auth[i].path.len, self->auth[i].path.mem);
    }

    fprintf(out , "\n");
    fclose(out);
}


fn i_get_secret (vault::Vault *self, identity::Secret  mut * secret)
{
    let this = (Mem mut*)self->user;
    static_attest(safe(this));

    memcpy(secret, &this->secret, sizeof(identity::Secret));
}

fn i_get_network (vault::Vault *self, identity::Address mut * network)
{
    let this = (Mem mut*)self->user;
    static_attest(safe(this));

    memcpy(network, &this->network, sizeof(identity::Address));
}

fn i_advance_clock (vault::Vault *self) -> u64
{
    let now = time::real();
    return now.to_millis();
}

fn i_set_network (vault::Vault *self, err::Err+et mut *e, identity::Secret * secret)
    where err::checked(*e)
{
    let this = (Mem mut*)self->user;
    static_attest(safe(this));

    memcpy(&this->network_secret, secret, sizeof(identity::Secret));
    identity::address_from_secret(&this->network, &this->network_secret);

    save_to_toml(this, e);
}

fn i_del_authorization(vault::Vault mut * self, err::Err+et mut *e, identity::Identity *delme, char *resource)
    where err::checked(*e)
    where nullterm(resource)
{
    let this = (Mem mut*)self->user;
    static_attest(safe(this));

    for (usize mut i = 0; i < static(len(this->auth)); i++) {
        if !this->auth[i].used {
            continue;
        }
        if this->auth[i].identity.eq(delme) && this->auth[i].path.eq_cstr(resource) {
            this->auth[i].used = false;
            memset(this->auth + i, 0, sizeof(Authorize));
        }
    }
    save_to_toml(this, e);
}

fn i_add_authorization(vault::Vault mut * self,err::Err+et mut *e, identity::Identity *addme, char *resource)
    where err::checked(*e)
    where nullterm(resource)
{
    let this = (Mem mut*)self->user;
    static_attest(safe(this));

    for (usize mut i = 0; i < static(len(this->auth)); i++) {
        if this->auth[i].used {
            continue;
        }
        memcpy(&this->auth[i].identity, addme, sizeof(identity::Identity));
        this->auth[i].path.clear();
        this->auth[i].path.append_cstr(resource);
        this->auth[i].used = true;
        save_to_toml(this, e);
        return;
    }
    err::fail(e, err::OutOfTail, "too many [[authorize]] sections");
    return;
}

fn i_list_authorizations(vault::Vault * self, err::Err+et mut *e, vault::list_authorizations_cb cb, void mut * unsafe user)
    where err::checked(*e)
    where safe(cb)
{
    let this = (Mem mut*)self->user;
    static_attest(safe(this));

    for (usize mut i = 0; i < static(len(this->auth)); i++) {
        if !this->auth[i].used {
            continue;
        }
        cb(user, &this->auth[i].identity, this->auth[i].path.cstr());
    }
}
