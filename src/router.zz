using identity;
using err;
using noise;
using std;
using hex;
using byteorder;
using <assert.h>::{assert};
using <stdio.h>::{printf};
using <memory.h>::{strlen};
using channel;
using string;

enum Direction {
    Initiator2Responder,
    Responder2Initiator,
}

struct Router {
    string::String+1024     mut pkt;
    channel::Channel        mut broker;
}


pub fn new(channel::Channel brk) -> Router {
    return Router {
        broker: brk,
    };
}

pub fn push(Router mut* self, err::Err+et mut* e)
    where err::checked(*e)
{
    printf("incomming pkt %zu\n", (self->pkt).len);

    static_attest(len(self->pkt.mem) >= self->pkt.len);
    hex::dump((u8*)self->pkt.mem, self->pkt.len);

    if self->pkt.len < 4 + 8 + 8 + 16   {
        err::fail(e, 1, "too small");
        return;
    }

    // version 1B
    if (self->pkt.mem)[0] != 9 {
        err::fail(e, 1, "invalid version");
        return;
    }
    // reserved 3B
    // route    8B
    u8 *rkeymem = (u8*)self->pkt.mem + 4;
    static_attest(safe(rkeymem));
    static_attest(len(rkeymem) > 8);
    u64 routingkey = read_routing_key(rkeymem, 0);
    // counter  8B
    u64 counter = byteorder::from_be64(*(u64*)&(self->pkt.mem)[12]);
    printf("<> counter %lu\n", counter);
    usize mut at = 4 + 8 + 8;

    u8 mut * ciphertext     = (u8 mut*)self->pkt.mem + at;
    usize ciphertext_len    = self->pkt.len - at;
    static_attest(safe(ciphertext));
    static_attest(len(ciphertext) >= ciphertext_len);

    if ciphertext_len <= 16 {
        err::fail(e, 1, "too small");
        return;
    }

    if routingkey == (self->broker).route {
        channel::push(&(self->broker), e, ciphertext, ciphertext_len, counter);
    }
}



pub fn pull(Router mut* self, err::Err+et mut* e)
    where err::checked(*e)
{
    channel::pull(&(self->broker), e, &self->pkt);
}





pub fn read_routing_key( u8 * i, Direction mut * unsafe direction) -> u64
    where len(i) >= 8
{
    if direction != 0 {
        static_attest(safe(direction));
        if (i[7] & 0b00000001) == 0 {
            *direction = Direction::Initiator2Responder;
        } else {
            *direction = Direction::Responder2Initiator;
        }
    }
    unsafe {
        u8 b[8] = {
            i[0],
            i[1],
            i[2],
            i[3],
            i[4],
            i[5],
            i[6],
            (i[7] & 0b11111110),
        };
        return *((u64*)b);
    }
}

