using identity;
using err;
using noise;
using hex;
using byteorder;
using <stdio.h>::{printf};
using <string.h>::{strlen, memset};
using channel;
using string;
using io;
using net::address;
using net::udp;
using log;
using endpoint;
using publish;


export symbol OutOfOptions;

const usize MAX_CHANNELS = 6;

enum Direction {
    Initiator2Responder,
    Responder2Initiator,
}

export struct Router {
    string::String+1500     mut pkt;

    udp::Socket             mut udp4;
    udp::Socket             mut udp6;

    channel::Channel        mut channels[MAX_CHANNELS];
}

pub fn make(channel::Channel brk, udp::Socket udp4, udp::Socket udp6) -> Router {
    return Router {
        channels:   {brk},
        udp4:       udp4,
        udp6:       udp6,
    };
}

pub fn close(Router mut* self)
{
    self->udp4.close();
    self->udp6.close();
}

pub fn poll(Router mut*self, err::Err+et mut*e, io::Async mut* async) -> io::Result
    where err::checked(*e)
{
    address::Address mut fromaddr = {0};
    self->pkt.clear();
    if self->udp4.recvfrom(e, &self->pkt, &fromaddr) == io::Result::Ready {
        err::make(e);
        if !self->push(e) {
            return io::Result::Error;
        }
    }
    if err::check(e) {
        e->elog();
        e->make();
    }

    bool mut again = true;
    while again {
        again = false;
        for (usize mut j = 0; j < static(len(self->channels)); j++) {
            if self->channels[j].route == 0 {
                continue;
            }
            //log::debug("polling chan %zu : %lu", j, self->channels[j].route);
            if self->channels[j].poll (e, async, &self->pkt) == io::Result::Ready {
                again = true;
                if err::check(e) { return io::Result::Error; }
                bool mut has_any_addr = false;
                for (usize mut i = 0; i < static(len(self->channels[j].peering.paths)); i++) {
                    if self->channels[j].peering.paths[i].active {
                        has_any_addr = true;

                        string::String+100 mut s = {0};
                        self->channels[j].peering.paths[i].addr.to_string(&s);
                        //log::debug("    sending to %.*s", s.len, s.mem);

                        switch self->channels[j].peering.paths[i].addr.typ {
                            address::Type::Invalid => {
                            }
                            address::Type::Ipv4 => {
                                if io::valid(&self->udp4) {
                                    self->udp4.sendto(e, &self->pkt, &self->channels[j].peering.paths[i].addr);
                                    if err::check(e) {
                                        e->elog();
                                    }
                                    e->make();
                                }
                            }
                            address::Type::Ipv6 => {
                                if io::valid(&self->udp6) {
                                    self->udp6.sendto(e, &self->pkt, &self->channels[j].peering.paths[i].addr);
                                    e->make();
                                }
                            }
                        }
                    }
                }
                if !has_any_addr {
                    err::fail(e, OutOfOptions, "no addr to send to");
                }
            }
        }
    }

    if err::check(e) {
        return io::Result::Error;
    }

    return io::Result::Later;
}

pub fn push(Router mut* self, err::Err+et mut* e) -> bool /*keep going*/
    where err::checked(*e)
{
    if self->pkt.len < 4 + 8 + 8 + 16   {
        err::fail(e, channel::InvalidFrame, "too small");
        return true;
    }

    // version 1B
    let version = (self->pkt.mem)[0];
    if version < 8 {
        err::fail(e, channel::InvalidFrame, "invalid version");
        return true;
    }
    // reserved 3B
    // route    8B
    u8 *rkeymem = (u8*)self->pkt.mem + 4;
    static_attest(safe(rkeymem));
    static_attest(len(rkeymem) > 8);
    u64 routingkey = read_routing_key(rkeymem, 0);
    // counter  8B
    u64 counter = byteorder::from_be64(*(u64*)&(self->pkt.mem)[12]);



    usize mut at = 4 + 8 + 8;

    u8 mut * ciphertext     = (u8 mut*)self->pkt.mem + at;
    usize ciphertext_len    = self->pkt.len - at;
    static_attest(safe(ciphertext));
    static_attest(len(ciphertext) >= ciphertext_len);

    if ciphertext_len <= 16 {
        err::fail(e, channel::InvalidFrame, "too small");
        return true;
    }

    for (usize mut i = 0; i < static(len(self->channels)); i++) {
        if self->channels[i].route == routingkey {
            channel::push(&self->channels[i], e, ciphertext, ciphertext_len, counter, version);
            if err::check(e) {
                if self->channels[i].errors_are_fatal {
                    return false;
                } else {
                    e->elog();
                    e->make();
                }
            }
            return true;
        }
    }
    log::debug("unroutable pkt. size: %zu, counter: %zu, route: %zu", (self->pkt).len, counter, routingkey);
    return true;
}


pub fn read_routing_key(u8 * i, Direction mut * unsafe direction) -> u64
    where len(i) >= 8
{
    if direction != 0 {
        static_attest(safe(direction));
        if (i[7] & 0b00000001) == 0 {
            *direction = Direction::Initiator2Responder;
        } else {
            *direction = Direction::Responder2Initiator;
        }
    }
    unsafe {
        u8 b[8] = {
            i[0],
            i[1],
            i[2],
            i[3],
            i[4],
            i[5],
            i[6],
            (i[7] & 0b11111110),
        };
        return *((u64*)b);
    }
}

pub fn next_channel(Router mut* self) -> channel::Channel mut * {
    for (usize mut i = 0; i < static(len(self->channels)); i++) {
        if self->channels[i].route == 0 {
            memset(self->channels + i, 0, sizeof(channel::Channel));
            return &self->channels[i];
        }
    }
    return 0;
}



export symbol Disconnected;

pub fn disconnect(Router mut* self, err::Err+et mut*e, u64 route)
    where err::checked(*e)
{
    for (usize mut i = 0; i < static(len(self->channels)); i++) {
        if self->channels[i].route == route {
            self->channels[i].cleanup(e);
            memset(&self->channels[i], 0, sizeof(channel::Channel));
            if i == 0 {
                err::fail(e, Disconnected, "broker channel closed");
            }
            if i != 0 {
                cleanup_dead_broker_route(&self->channels[0], route);
            }
        }
    }
}

fn cleanup_dead_broker_route(channel::Channel mut * chan, u64 dead_route)
{
    for (usize mut i = 0 ; i < static(len(chan->streams)); i++) {
        if chan->streams[i] == 0 {
            continue;
        }
        let strx = chan->streams[i];
        static_attest(safe(strx));
        if strx->broker_route == dead_route {
            strx->closing = true;
        }
    }
}
