using carrier::cipher;
using error;
using hex;
using <string.h>::{memcmp};

pub fn main() -> int {

    error::Error mut err = {0};

    u8 key[] = {
        0xee, 0x9d, 0x3f, 0xd,  0x82, 0x18, 0x57, 0x3b,
        0xec, 0x7e, 0x7e, 0xcd, 0x57, 0x6f, 0xd5, 0x5a,
        0x38, 0xa3, 0x99, 0x28, 0xc4, 0x65, 0x35, 0x3e,
        0xa5, 0xed, 0x10, 0x50, 0x1,  0xf9, 0xbb, 0xd1,
    };

    u8 ciphertext[] = {
        0xa9, 0x65, 0xf3, 0x42, 0x77, 0x71, 0x42, 0xd6,
        0xb1, 0xa7, 0x8e, 0xbe, 0x57, 0x8d, 0x75, 0x60,
        0x24, 0xfb, 0x4e, 0x0,  0x7f, 0x71, 0x3e, 0xfc,
        0xbd, 0x11, 0x21, 0xb2, 0xb5, 0x7f, 0x2a, 0xe5,
        0xf1, 0x30, 0x77, 0x84, 0x79, 0x2e, 0x5,  0xda,
        0x4,  0x9c, 0x74, 0xf6, 0x51, 0xf6, 0xb7, 0xdb,
        0xd6, 0xfb, 0x46, 0xbd, 0xf3, 0x80, 0xd5, 0x82,
        0x5e, 0x70, 0xb3, 0x46, 0xb2, 0x82, 0x4b, 0xd6
    };


    u8 plaintext[] = {
        0x0, 0x0, 0x0, 0xd, 0x1, 0x0, 0x0, 0x0, 0x1,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    };

    u64 nonce = 1;

    cipher::CipherState mut c = {0};
    cipher::init(&c, key);

    u8 mut plain[1000] = {0};
    usize len = cipher::decrypt(&c, &err, ciphertext, len(ciphertext), nonce, plain, len(plain));
    error::abort(&err);

    if memcmp(plain, plaintext, sizeof(plaintext)) != 0 {
        hex::dump(plain, len);
        hex::dump(plaintext, sizeof(plaintext));
        return 9;
    }

    return 0;
}
