using carrier;
using carrier::identity::{
    Address,
    Identity,
    Secret,
    identity_from_str,
    identity_from_cstr,
    identity_from_secret,
    identity_to_str,
    secret_from_str,
    secret_from_cstr,
    secret_to_str,
    address_from_secret,
    address_to_str,
    address_from_str,
    address_from_cstr,
    secret_generate,
};
using err;
using <string.h>::{memcmp};
using <stdio.h>::{printf};
using <assert.h>::{assert};
using string;

fn test_identity(err::Err+et mut* e)
    where err::checked(*e)
{
    new sk = secret_generate(e);
    if err::check(e) { return; }

    Identity mut pk = {0};
    identity_from_secret(&pk, &sk);

    char mut buf[50] = {0};
    identity_to_str(e, buf, static(len(buf)), &pk);
    if err::check(e) { return; }

    printf("%s\n", buf);

    new pk2 = identity_from_cstr(e, buf);
    if err::check(e) { return; }

    assert(memcmp(pk.k, pk2.k, sizeof(pk.k)) == 0);

    secret_to_str(e, buf, static(len(buf)), &sk);
    if err::check(e) { return; }

    printf("%s\n", buf);

    new sk2 = secret_from_cstr(e, buf);
    if err::check(e) { return; }

    assert(memcmp(sk.k, sk2.k, sizeof(sk.k)) == 0);
exit:
    return;
}

fn test_corrupt_identity(err::Err+et mut* e)
    where err::checked(*e)
{
    char *from = "oWVXR9hGa6QgKLGrPaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";

    new sk = secret_from_cstr(e, from);
    if !err::check(e) {
        err::fail(e, err::InvalidArgument, "must fail");
        return;
    }
    e->error = 0;
    static_attest(err::checked(*e));

    new ik = identity_from_cstr(e, from);
    if !err::check(e) {
        err::fail(e, err::InvalidArgument, "must fail");
        return;
    }
    e->error = 0;
}

fn test_address(err::Err+et mut* e)
    where err::checked(*e)
{
    new sk = secret_generate(e);
    if err::check(e) { return; }

    Address mut pk = {0};
    address_from_secret(&pk, &sk);

    char mut buf[50] = {0};
    address_to_str(e, buf, static(len(buf)), &pk);
    if err::check(e) { return; }

    printf("%s\n", buf);

    new pk2 = address_from_cstr(e,buf);
    if err::check(e) { return; }

    assert(memcmp(pk.k, pk2.k, sizeof(pk.k)) == 0);
}

export fn main() -> int {
    new+1000 e = err::make();

    test_identity(&e);
    err::abort(&e);

    test_corrupt_identity(&e);
    err::abort(&e);

    test_address(&e);
    err::abort(&e);

    return 0;
}
