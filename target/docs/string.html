
<h1> module string </h1>
<h4> fn substr (

    usize
    size,

    ::string::String*+tail2
    other,

    usize
    tail2,

    usize
    tail,

    ::string::String*+tail
    self,

    usize
    from,

)



</h4>

<p class='doc_comments'>
 copy parts of this string to other string&lt;br&gt;
</p><h4> fn cstr (

    ::string::String*
    self,

)

-&gt ::ext::&lt;stddef.h&gt;::char*

</h4>

<p class='doc_comments'>
 string as null terminated c string&lt;br&gt;
</p><h4> fn append (

    usize
    t,

    ::string::String*+t2
    other,

    ::string::String*+t
    self,

    usize
    t2,

)



</h4>

<p class='doc_comments'>
 append another string&lt;br&gt;
</p><h4> fn clear (

    usize
    tail,

    ::string::String*+tail
    self,

)



</h4>

<p class='doc_comments'>
 clear the string&lt;br&gt;
</p><h4> fn starts_with_cstr (

    ::ext::&lt;stddef.h&gt;::char*
    a,

    ::string::String*+tail
    self,

    usize
    tail,

)

-&gt bool

</h4>

<p class='doc_comments'>
 test if this string begings with some c string&lt;br&gt;
</p><h4> fn space (

    usize
    tail,

    ::string::String*+tail
    self,

)

-&gt usize

</h4>

<p class='doc_comments'>
 returns the amount of bytes still left in the tail&lt;br&gt;
</p><h4> fn cstr_eq (

    ::ext::&lt;stddef.h&gt;::char*
    b,

    ::ext::&lt;stddef.h&gt;::char*
    a,

)

-&gt bool

</h4>

<p class='doc_comments'>
 test if some c string is equal another c string&lt;br&gt;
</p><h4> fn strlen (

    ::ext::&lt;stddef.h&gt;::char*
    s,

)

-&gt usize

</h4>

<p class='doc_comments'>
 length of a null terminated c string&lt;br&gt;
</p><h4> fn append_bytes (

    u8*
    bytes,

    usize
    t,

    ::string::String*+t
    self,

    usize
    inlen,

)



</h4>

<p class='doc_comments'>
 append raw bytes with given len&lt;br&gt;
</p><h4> fn vformat (

    ::ext::&lt;stddef.h&gt;::char*
    fmt,

    ::string::String*+tail
    self,

    ::ext::&lt;stdarg.h&gt;::va_list
    args,

    usize
    tail,

)

-&gt int

</h4>

<p class='doc_comments'>

</p><h4> fn fgets (

    usize
    tail,

    ::string::String*+tail
    self,

    ::ext::&quot;&#x2f;home&#x2f;aep&#x2f;proj&#x2f;zz&#x2f;modules&#x2f;string&#x2f;src&#x2f;native.h&quot;::FILE*
    stream,

)

-&gt bool

</h4>

<p class='doc_comments'>
 append to this string by reading from a FILE&lt;br&gt;
</p><h4> fn append_cstr (

    usize
    t,

    ::string::String*+t
    self,

    ::ext::&lt;stddef.h&gt;::char*
    cstr,

)



</h4>

<p class='doc_comments'>
 append a null terminated c string&lt;br&gt;
</p><h4> fn split (

    usize
    tail,

    ::string::String*+tail2
    other,

    usize*
    iterator,

    usize
    tail2,

    ::ext::&lt;stddef.h&gt;::char
    token,

    ::string::String*+tail
    self,

)

-&gt bool

</h4>

<p class='doc_comments'>
 split this string by token and copy the substring into other&lt;br&gt;
</p><h4> fn slice (

    usize
    tail,

    ::string::String*+tail
    self,

)

-&gt ::slice::slice::Slice

</h4>

<p class='doc_comments'>
 string as slice&lt;br&gt;
</p><h4> fn slen (

    ::string::String*
    self,

)

-&gt usize

</h4>

<p class='doc_comments'>
 length of string (excluding null terminator)&lt;br&gt;
</p><h4> fn pop (

    ::string::String*+t
    self,

    usize
    t,

)

-&gt bool

</h4>

<p class='doc_comments'>
 remove the last character&lt;br&gt;&lt;br&gt; returns false if string was empty&lt;br&gt;
</p><h4> fn append_slice (

    usize
    tail,

    ::string::String*+tail
    self,

)

-&gt ::slice::mut_slice::MutSlice

</h4>

<p class='doc_comments'>
 append a slice to this string&lt;br&gt;
</p><h4> fn format (

    ::ext::&lt;stddef.h&gt;::char*
    fmt,

    ::string::String*+tail
    self,

    usize
    tail,

)

-&gt int

</h4>

<p class='doc_comments'>
 append formated string with vsnprintf&lt;br&gt;
</p><h4> fn eq_cstr (

    ::ext::&lt;stddef.h&gt;::char*
    b,

    ::string::String*+tail
    self,

    usize
    tail,

)

-&gt bool

</h4>

<p class='doc_comments'>
 test if this string is equal with a c string&lt;br&gt;
</p><h4> fn push (

    ::string::String*+t
    self,

    usize
    t,

    ::ext::&lt;stddef.h&gt;::char
    cstr,

)

-&gt bool

</h4>

<p class='doc_comments'>
 push a single character&lt;br&gt;
</p><h4> fn ends_with_cstr (

    ::string::String*+tail
    self,

    usize
    tail,

    ::ext::&lt;stddef.h&gt;::char*
    a,

)

-&gt bool

</h4>

<p class='doc_comments'>
 test if self ends with other string&lt;br&gt;
</p><h4> fn make (

    ::string::String*+tail
    self,

    usize
    tail,

)



</h4>

<p class='doc_comments'>
 make an empty string&lt;br&gt;
</p>






















